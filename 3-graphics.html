<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
	<meta charset="utf-8"><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>üëæ 3 Graphics &mdash; OpenXR Tutorial  documentation</title>
	<link rel="stylesheet" href="_static/pygments.css" type="text/css">
	<link rel="stylesheet" href="_static/css/theme.css" type="text/css">
	<link rel="shortcut icon" href="_static/favicon.ico">
	<!--[if lt IE 9]>
	  <script src="_static/js/html5shiv.min.js"></script>
	<![endif]-->
	
	<script src="_static/jquery.js"></script>
	<script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
	<script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
	<script src="_static/doctools.js"></script>
	<script src="_static/sphinx_highlight.js"></script>
	<script src="https://unpkg.com/mermaid@9.4.0/dist/mermaid.min.js"></script>
	<script>mermaid.initialize({startOnLoad:true});</script>
	<script src="_static/js/theme.js"></script>
	<link rel="index" title="Index" href="genindex.html" >
	<link rel="search" title="Search" href="search.html" >
	<link rel="next" title="üïπ 4 Interactions" href="4-actions.html" >
	<link rel="prev" title="‚öôÔ∏è 2 Setup" href="2-setup.html" > 
	<script  src="_static/js/js.cookie.min.js"></script>
	<script >
	function updatePlatform()
	{
	var platform = Cookies.get("platform");
	console.log("updatePlatform(), platform = " + platform);
	if (typeof platform == 'undefined')
	{
		platform = "linux"; // Set default here.
	}
	$(".linux").hide();
	$(".android").hide();
	$(".windows").hide();
	if (platform == "windows")
	{
		$(".windows").show();
		$(".selectd3d11").disabled = false;
		$(".selectd3d12").disabled = false;
		$(".selectopengles").disabled = true;
		$(".selectvulkan").disabled = false;
		$(".selectopengl").disabled = false;
	}
	if (platform == "linux")
	{
		$(".linux").show();
		$(".selectd3d11").disabled = true;
		$(".selectd3d12").disabled = true;
		$(".selectopengles").disabled = true;
		$(".selectvulkan").disabled = false;
		$(".selectopengl").disabled = false;
	}
	if (platform == "android")
	{
		$(".android").show();
		$(".selectd3d11").disabled = true;
		$(".selectd3d12").disabled = true;
		$(".selectopengles").disabled = false;
		$(".selectvulkan").disabled = false;
		$(".selectopengl").disabled = true;
	}
	var oldelements = document.querySelectorAll(".selected-platform");
	console.log("selected-platform on "+oldelements.length+" elements.");
	while (oldelements.length > 0)
	{
		var el=oldelements.item(0);
		el.classList.remove('selected-platform');
		console.log("Removing selected-platform from "+el.id);
		oldelements = document.querySelectorAll(".selected-platform");
	}
	var element = document.getElementById('select' + platform);
	if(element)
	{
		element.classList.add('selected-platform');
		console.log("Adding selected-platform to "+element.id);
	}
	var element2 = document.getElementById('select' + platform + "-inline");
	if(element2)
	{
		element2.classList.add('selected-platform');
		console.log("Adding selected-platform to "+element2.id);
	}
	else
	{
		console.log('select' + platform + "-inline not found");
	}
	if(limitAPIChoice())
		updateGraphicsAPI();
	window.updatePlatform=updatePlatform;
	}
	
	function limitAPIChoice()
	{
		var platform = Cookies.get("platform");
		var graphicsApi = Cookies.get("graphicsapi")
		console.log("limitAPIChoice(), platform = " + platform+", graphicsApi = "+graphicsApi);
		window.limitAPIChoice=limitAPIChoice;
		var newApi=graphicsApi;
		if (platform == "windows")
		{
			if (graphicsApi == "opengles"||graphicsApi==undefined)
				newApi="vulkan";
		}
		if (platform == "linux")
		{
			if (graphicsApi == "opengles"||graphicsApi=="d3d11"||graphicsApi=="d3d12"||graphicsApi==undefined)
				newApi="vulkan";
		}
		if (platform == "android"||graphicsApi==undefined)
		{
			if (graphicsApi != "opengles"&&graphicsApi!="vulkan")
				newApi="vulkan";
		}
		console.log("newApi = "+newApi);
		if (newApi != graphicsApi)
		{
			console.log("setting graphicsapi = "+newApi);
			Cookies.set('graphicsapi', newApi,{ expires: 365})
			graphicsApi=newApi;
			return true;
		}
		return false;
	}
	function makeLinksOpenInNewWindow()
	{ 
		console.log("makeLinksOpenInNewWindow ");
		var download_hrefs = document.getElementsByClassName('reference download internal');
		[].forEach.call(download_hrefs, function(el) {
			el.setAttribute('target', "_blank");
			console.log("Adding target blank to "+el.id);
		});
		link_hrefs = document.getElementsByClassName('reference external');
		[].forEach.call(link_hrefs, function(el) {
			el.setAttribute('target', "_blank");
			console.log("Adding target blank to "+el.id);
		});
		window.makeLinksOpenInNewWindow=makeLinksOpenInNewWindow;
	}
	function updateGraphicsAPI()
	{
		var graphicsApi = Cookies.get("graphicsapi")
		console.log("graphicsapi = " + graphicsApi);
		if (typeof graphicsApi == 'undefined')
		{
			graphicsApi = "vulkan"; // Set default here.
		}
		// first, hide all the api's
		$(".d3d11").hide();
		$(".d3d12").hide();
		$(".opengl").hide();
		$(".opengles").hide();
		$(".vulkan").hide();
		// Now, show the wanted api's. In this way, divs with more than one will be shown, even if they have one that is hidden.
		if (graphicsApi == "d3d11") {
			$(".d3d11").show();
		}
		if (graphicsApi == "d3d12") {
			$(".d3d12").show();
		}
		if (graphicsApi == "opengl") {
			$(".opengl").show();
		}
		if (graphicsApi == "opengles") {
			$(".opengles").show();
		}
		if (graphicsApi == "vulkan") {
			$(".vulkan").show();
		}
		var oldelements = document.querySelectorAll(".selected-graphics-api");
		console.log("selected-platform on "+oldelements.length+" elements.");
		while (oldelements.length > 0)
		{
			var el=oldelements.item(0);
			el.classList.remove('selected-graphics-api');
			console.log("Removing selected-graphics-api from "+el.id);
			oldelements = document.querySelectorAll(".selected-graphics-api");
		}
		var element = document.getElementById('select' + graphicsApi);
		if(element)
		{
			element.classList.add('selected-graphics-api');
		}
		var element2 = document.getElementById('select' + graphicsApi +"-inline");
		if (element2)
		{
			element2.classList.add('selected-graphics-api');
		}
		window.updateGraphicsAPI=updateGraphicsAPI;
	}</script>
	<script >
	var graphicsApi = Cookies.get("graphicsapi")
	if (graphicsApi==undefined) {
		Cookies.set('graphicsapi', 'vulkan',{ expires: 365})
		graphicsApi='vulkan';
	}
	</script>
	<style>
	@import url('https://fonts.googleapis.com/css2?family=Poppins&display=swap');
	@import url('https://fonts.cdnfonts.com/css/menlo');
	</style>
</head>

<body class="wy-body-for-nav" onload="updatePlatform(); updateGraphicsAPI(); makeLinksOpenInNewWindow();"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
			<a href="index.html"  class="" >
				<img src="_static/OpenXR_170px_Feb17.png" class="logo" alt="The OpenXR logo" >
				
				<span class="sidebartitle">
					Tutorial
				</span>
				
			</a>
<div role="search">
    <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
        <label class="search-label" for="q">Search the tutorial</label>
        <input type="text" name="q" id="q" placeholder="Search..." aria-label="Search docs">
        <input type="hidden" name="check_keywords" value="yes">
        <input type="hidden" name="area" value="default">
    </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="1-introduction.html">üëã 1 Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="2-setup.html">‚öôÔ∏è 2 Setup</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">üëæ 3 Graphics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#creating-swapchains">3.1 Creating Swapchains</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#xrviewconfigurationview">3.1.1 XrViewConfigurationView</a></li>
<li class="toctree-l3"><a class="reference internal" href="#xrenumerateswapchainformats">3.1.2 xrEnumerateSwapchainFormats</a></li>
<li class="toctree-l3"><a class="reference internal" href="#xrcreateswapchain">3.1.3 xrCreateSwapchain</a></li>
<li class="toctree-l3"><a class="reference internal" href="#xrenumerateswapchainimages">3.1.4 xrEnumerateSwapchainImages</a></li>
<li class="toctree-l3"><a class="reference internal" href="#create-depth-image-and-image-views">3.1.5 Create Depth Image And Image Views</a></li>
<li class="toctree-l3"><a class="reference internal" href="#xrdestroyswapchain">3.1.6 xrDestroySwapchain</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#building-a-renderloop">3.2 Building a RenderLoop</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#xrenumerateenvironmentblendmodes">3.2.1 xrEnumerateEnvironmentBlendModes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#xrcreatereferencespace">3.2.2 xrCreateReferenceSpace</a></li>
<li class="toctree-l3"><a class="reference internal" href="#renderframe">3.2.3 RenderFrame</a></li>
<li class="toctree-l3"><a class="reference internal" href="#renderlayer">3.2.4 RenderLayer</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="4-actions.html">üïπ 4 Interactions</a></li>
<li class="toctree-l1"><a class="reference internal" href="5-extensions.html">‚ú® 5 Extensions</a></li>
</ul>

        </div>
      </div>
    </nav>

	<div data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
			<i data-toggle="wy-nav-top" class="fa fa-bars"></i>
			<a href="index.html">OpenXR Tutorial</a>
		</nav>

		<div class="sticky-breadcrumb-ribbon" role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">üëæ 3 Graphics</li>
	  <li class="disclaimer">Disclaimer: Work in Progress. This site is in progress and is not ready for use.</li>
	  <li class="wy-breadcrumbs-aside">
		  <div id='selectplatform'>
	<button class="select-platform" id='selectwindows' onclick="choosePlatform('windows')">
		<img class="platform-tab-img" src="_static/css/windows-colour.svg" alt="Windows" />
	</button>
	<button class="select-platform" id='selectlinux' onclick="choosePlatform('linux')">
		<img class="platform-tab-img" src="https://upload.wikimedia.org/wikipedia/commons/3/35/Tux.svg" alt="Linux" />
	</button>
	<button class="select-platform" id='selectandroid' onclick="choosePlatform('android')">
		<img class="platform-tab-img" src="_static/css/android-colour.svg" alt="Android" />
	</button>
</div>
<script>
	function choosePlatform(platformName)
	{
		var platform = Cookies.get('platform')
		Cookies.set('platform', platformName, { expires: 365 })
		updatePlatform();
	};
</script>

<div id='selectgraphicsapi'>
	<button class="select-graphics-api selectd3d11" id='selectd3d11' onclick="chooseGraphicsAPI('d3d11')">
		<img class="api-tab-img" src="_static/css/d3d11.png" alt="DirectX 11" />
	</button>
	<button class="select-graphics-api selectd3d12" id='selectd3d12' onclick="chooseGraphicsAPI('d3d12')">
		<img class="api-tab-img" src="_static/css/d3d12.png" alt="DirectX 12" />
	</button>
	<button class="select-graphics-api selectopengl" id='selectopengl' onclick="chooseGraphicsAPI('opengl')">
		<img class="api-tab-img" src="_static/css/opengl.png" alt="OpenGL" />
	</button>
	<button class="select-graphics-api selectopengles" id='selectopengles' onclick="chooseGraphicsAPI('opengles')">
		<img class="api-tab-img" src="_static/css/opengles.png" alt="OpenGL ES" />
	</button>
	<button class="select-graphics-api selectvulkan" id='selectvulkan' onclick="chooseGraphicsAPI('vulkan')">
		<img class="api-tab-img" src="_static/css/vulkan.png" alt="Vulkan" />
	</button>
</div>
<script>
	function chooseGraphicsAPI(graphicsApiName)
	{
		Cookies.set('graphicsapi', graphicsApiName, { expires: 365 })
		var graphicsApi = Cookies.get('graphicsapi')
		updateGraphicsAPI();
		limitAPIChoice();
	};
</script>
	  </li>
  </ul>
</div>
		<div class="wy-nav-content">
				<div class="rst-content">
					<div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
						<div itemprop="articleBody">
							
  <section id="graphics">
<h1>üëæ 3 Graphics<a class="headerlink" href="#graphics" title="Permalink to this heading">¬∂</a></h1>
<p>Select your platform, as the instructions are different depending on your selection.</p>
<div class='select-platform-container-inline'>
	<button class="select-platform-inline" id='selectwindows-inline' onclick="choosePlatform('windows')">
		<img src="_static/css/windows-mono.svg" alt="Windows" />
		Windows
	</button>
	<button class="select-platform-inline" id='selectlinux-inline' onclick="choosePlatform('linux')">
		<img src="https://upload.wikimedia.org/wikipedia/commons/3/35/Tux.svg" alt="Linux" />
		Linux
	</button>
	<button class="select-platform-inline" id='selectandroid-inline' onclick="choosePlatform('android')">
		<img src="_static/css/android-original.svg" alt="Android" />
		Android
	</button>
</div>
<div class='select-graphics-api-container-inline'>
	<button class="select-graphics-api-inline selectd3d11" id='selectd3d11-inline' onclick="chooseGraphicsAPI('d3d11')">
		<img src="_static/css/d3d11.png" alt="DirectX 11" />
		DirectX 11
	</button>
	<button class="select-graphics-api-inline selectd3d12" id='selectd3d12-inline' onclick="chooseGraphicsAPI('d3d12')">
		<img src="_static/css/d3d12.png" alt="DirectX 12" />
		DirectX 12
	</button>
	<button class="select-graphics-api-inline selectopengl" id='selectopengl-inline' onclick="chooseGraphicsAPI('opengl')">
		<img src="_static/css/opengl.png" alt="OpenGL" />
		OpenGL
	</button>
	<button class="select-graphics-api-inline selectopengles" id='selectopengles-inline' onclick="chooseGraphicsAPI('opengles')">
		<img src="_static/css/opengles.png" alt="OpenGL ES" />
		OpenGL ES
	</button>
	<button class="select-graphics-api-inline selectvulkan" id='selectvulkan-inline' onclick="chooseGraphicsAPI('vulkan')">
		<img src="_static/css/vulkan.png" alt="Vulkan" />
		Vulkan
	</button>
</div>

<p>The goal of this chapter is to build an application that creates and clears color and depth buffers within the scope of OpenXR render loop and to demonstrate its interaction with all the Graphics APIs.</p>
<section id="creating-swapchains">
<h2>3.1 Creating Swapchains<a class="headerlink" href="#creating-swapchains" title="Permalink to this heading">¬∂</a></h2>
<p>As with rendering graphics to a 2D display, OpenXR has the concept of swapchains. It‚Äôs series of images that are used to present the rendered graphics to display/window/view. There are usually 2 or 3 images in the swapchain to allow the platform to present them smoothly to the user in order to create illusion of motion within the image.</p>
<p>All graphics APIs have this concept of a swapchain with differing levels of transparency to the programmer, but for an OpenXR application we don‚Äôt use the API-specific swapchain, which can be tied closely the platform‚Äôs windowing system. Instead, we use OpenXR‚Äôs swapchain and the OpenXR compositor to present rendered graphics to the views. XR applications are unique in that often, but not always, have multiple views that need to be rendered to create the XR experience. Listed below are a few scenarios with differing view counts:</p>
<blockquote>
<div><ul class="simple">
<li><p>1 view  - AR viewer on a mobile device.</p></li>
<li><p>2 views - VR head mounted display.</p></li>
</ul>
</div></blockquote>
<p>Orthogonal to multiple views is the layering of multiple rendered images or camera feeds. You could, for a example, have a background that is a video pass-through of your environment, a stereo view of rendering graphics and quad overlay of a HUD or UI elements; all of of which could have different spatial orientations. This layering of views is handled by the XR compositor to composite correctly the layers for each view - that quad overlay might be behind the user, and thus shouldn‚Äôt be rendered to the eye views.</p>
<p>Firstly, we will update the class to add the new methods and members.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">OpenXRTutorial</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">        </span><span class="c1">// [...]</span>

<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="n">Run</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">CreateInstance</span><span class="p">();</span>
<span class="w">                </span><span class="n">CreateDebugMessenger</span><span class="p">();</span>

<span class="w">                </span><span class="n">GetInstanceProperties</span><span class="p">();</span>
<span class="w">                </span><span class="n">GetSystemID</span><span class="p">();</span>

<span class="w">                </span><span class="n">GetViewConfigurationViews</span><span class="p">();</span>

<span class="w">                </span><span class="n">CreateSession</span><span class="p">();</span>
<span class="w">                </span><span class="n">CreateSwapchain</span><span class="p">();</span>

<span class="w">                </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">applicationRunning</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                        </span><span class="n">PollSystemEvents</span><span class="p">();</span>
<span class="w">                        </span><span class="n">PollEvents</span><span class="p">();</span>
<span class="w">                        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sessionRunning</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                                </span><span class="c1">// Draw Frame.</span>
<span class="w">                        </span><span class="p">}</span>
<span class="w">                </span><span class="p">}</span>

<span class="w">                </span><span class="n">DestroySwapchain</span><span class="p">();</span>
<span class="w">                </span><span class="n">DestroySession</span><span class="p">();</span>

<span class="w">                </span><span class="n">DestroyDebugMessenger</span><span class="p">();</span>
<span class="w">                </span><span class="n">DestroyInstance</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">private</span><span class="o">:</span>
<span class="w">        </span><span class="c1">// [...]</span>

<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">XrViewConfigurationView</span><span class="o">&gt;</span><span class="w"> </span><span class="n">viewConfigurationViews</span><span class="p">;</span>
<span class="w">        </span><span class="c1">// [...]</span>

<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">SwapchainAndDepthImage</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">XrSwapchain</span><span class="w"> </span><span class="n">swapchain</span><span class="p">{};</span>
<span class="w">                </span><span class="kt">int64_t</span><span class="w"> </span><span class="n">swapchainFormat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">                </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">depthImage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>

<span class="w">                </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">void</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="n">colorImageViews</span><span class="p">;</span>
<span class="w">                </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">depthImageView</span><span class="p">;</span>
<span class="w">        </span><span class="p">};</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SwapchainAndDepthImage</span><span class="o">&gt;</span><span class="w"> </span><span class="n">swapchainAndDepthImages</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<section id="xrviewconfigurationview">
<h3>3.1.1 XrViewConfigurationView<a class="headerlink" href="#xrviewconfigurationview" title="Permalink to this heading">¬∂</a></h3>
<p>The first thing we need to do is get all of the views available to our view configuration. It is worth just parsing the name of this type: <code class="docutils literal notranslate"><span class="pre">XrViewConfigurationView</span></code>. I break the typename up as follow ‚ÄúXrViewConfiguration‚Äù - ‚ÄúView‚Äù, where it relates to one view in the view configuration, which may contain multiple views. We call <code class="docutils literal notranslate"><span class="pre">xrEnumerateViewConfigurationViews()</span></code> twice, first to get the count of the views in the view configuration, and second to fill in the data to the <code class="docutils literal notranslate"><span class="pre">std::vector&lt;XrViewConfigurationView&gt;</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">GetViewConfigurationViews</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">viewConfigurationViewSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">OPENXR_CHECK</span><span class="p">(</span><span class="n">xrEnumerateViewConfigurationViews</span><span class="p">(</span><span class="n">m_xrInstance</span><span class="p">,</span><span class="w"> </span><span class="n">m_systemID</span><span class="p">,</span><span class="w"> </span><span class="n">m_viewConfiguration</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">viewConfigurationViewSize</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Failed to enumerate ViewConfiguration Views.&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">m_viewConfigurationViews</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">viewConfigurationViewSize</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">XR_TYPE_VIEW_CONFIGURATION_VIEW</span><span class="p">});</span>
<span class="w">    </span><span class="n">OPENXR_CHECK</span><span class="p">(</span><span class="n">xrEnumerateViewConfigurationViews</span><span class="p">(</span><span class="n">m_xrInstance</span><span class="p">,</span><span class="w"> </span><span class="n">m_systemID</span><span class="p">,</span><span class="w"> </span><span class="n">m_viewConfiguration</span><span class="p">,</span><span class="w"> </span><span class="n">viewConfigurationViewSize</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">viewConfigurationViewSize</span><span class="p">,</span><span class="w"> </span><span class="n">m_viewConfigurationViews</span><span class="p">.</span><span class="n">data</span><span class="p">()),</span><span class="w"> </span><span class="s">&quot;Failed to enumerate ViewConfiguration Views.&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="xrenumerateswapchainformats">
<h3>3.1.2 xrEnumerateSwapchainFormats<a class="headerlink" href="#xrenumerateswapchainformats" title="Permalink to this heading">¬∂</a></h3>
<p>Due to way that OpenXR and its composite operate, there are certain preferred image formats that should be used by the swapchain. When calling <code class="docutils literal notranslate"><span class="pre">xrEnumerateSwapchainFormats()</span></code>, the <code class="docutils literal notranslate"><span class="pre">XrSession</span></code> and alongwith the Graphics API will return an array of API-specific formats ordered in preference. <code class="docutils literal notranslate"><span class="pre">xrEnumerateSwapchainFormats()</span></code> takes a pointer to the first element in an array of <code class="docutils literal notranslate"><span class="pre">int64_t</span></code> values. The use of <code class="docutils literal notranslate"><span class="pre">int64_t</span></code> is a simple type cast from a <code class="docutils literal notranslate"><span class="pre">DXGI_FORMAT</span></code>, <code class="docutils literal notranslate"><span class="pre">GLenum</span></code> or a <code class="docutils literal notranslate"><span class="pre">VkFormat</span></code>. The runtime ‚Äúshould support <code class="docutils literal notranslate"><span class="pre">R8G8B8A8</span></code> and <code class="docutils literal notranslate"><span class="pre">R8G8B8A8</span> <span class="pre">sRGB</span></code> formats if possible‚Äù (<a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/html/xrspec.html#swapchain-image-management">OpenXR Specification 10.1. Swapchain Image Management</a>).</p>
<p>Linear or sRGB color space? OpenXR‚Äôs compositor performs all blend operations in a linear color space (i.e. the values have not been gamma encoded). Most gamma-encoding operations are algebraically non-linear, so you can‚Äôt composite the values with simple addition or multiplication operations. If you wish to use an sRGB color format, you must use an API-specific sRGB color format such as <code class="docutils literal notranslate"><span class="pre">DXGI_FORMAT_R8G8B8A8_UNORM_SRGB</span></code>, <code class="docutils literal notranslate"><span class="pre">GL_SRGB8_ALPHA8</span></code> or <code class="docutils literal notranslate"><span class="pre">VK_FORMAT_R8G8B8A8_SRGB</span></code>. The OpenXR runtime will automatically do sRGB-to-linear color space conversions when reading the image. There are two issues with this:</p>
<ol class="arabic simple">
<li><p>Runtime conversion of image data could be too slow and affect performance and comfort.</p></li>
<li><p>The conversion process may not use the same style of gamma encoding/decoding and there could be a loss in color accuracy.</p></li>
</ol>
<p>If you‚Äôd like more information on color spaces and gamma in computer graphics, Guy Davidson from Creative Assembly has a fantastic video presentation from Meeting C++ 2021 on this topic <a class="reference external" href="https://www.youtube.com/watch?v=_zQ_uBAHA4A">here</a>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">formatSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">OPENXR_CHECK</span><span class="p">(</span><span class="n">xrEnumerateSwapchainFormats</span><span class="p">(</span><span class="n">m_session</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">formatSize</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Failed to enumerate Swapchain Formats&quot;</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">formats</span><span class="p">(</span><span class="n">formatSize</span><span class="p">);</span>
<span class="n">OPENXR_CHECK</span><span class="p">(</span><span class="n">xrEnumerateSwapchainFormats</span><span class="p">(</span><span class="n">m_session</span><span class="p">,</span><span class="w"> </span><span class="n">formatSize</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">formatSize</span><span class="p">,</span><span class="w"> </span><span class="n">formats</span><span class="p">.</span><span class="n">data</span><span class="p">()),</span><span class="w"> </span><span class="s">&quot;Failed to enumerate Swapchain Formats&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Next, we do some checks to confirm that the views in the view configuration are the same size and thus suitable for stereo rendering. With this check done, we can alias to views together when create our <code class="docutils literal notranslate"><span class="pre">XrSwapchain</span></code>. We resize our <code class="docutils literal notranslate"><span class="pre">SwapchainAndDepthImage</span></code> structure and enter a for each loop to create all required resources.</p>
</section>
<section id="xrcreateswapchain">
<h3>3.1.3 xrCreateSwapchain<a class="headerlink" href="#xrcreateswapchain" title="Permalink to this heading">¬∂</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">XrSwapchainCreateInfo</span><span class="w"> </span><span class="n">swapchainCI</span><span class="p">{</span><span class="n">XR_TYPE_SWAPCHAIN_CREATE_INFO</span><span class="p">};</span>
<span class="n">swapchainCI</span><span class="p">.</span><span class="n">createFlags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">swapchainCI</span><span class="p">.</span><span class="n">usageFlags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">XR_SWAPCHAIN_USAGE_SAMPLED_BIT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">XR_SWAPCHAIN_USAGE_COLOR_ATTACHMENT_BIT</span><span class="p">;</span>
<span class="n">swapchainCI</span><span class="p">.</span><span class="n">format</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">SelectSwapchainFormat</span><span class="p">(</span><span class="n">formats</span><span class="p">);</span>
<span class="n">swapchainCI</span><span class="p">.</span><span class="n">sampleCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">viewConfigurationView</span><span class="p">.</span><span class="n">recommendedSwapchainSampleCount</span><span class="p">;</span>
<span class="n">swapchainCI</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">viewConfigurationView</span><span class="p">.</span><span class="n">recommendedImageRectWidth</span><span class="p">;</span>
<span class="n">swapchainCI</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">viewConfigurationView</span><span class="p">.</span><span class="n">recommendedImageRectHeight</span><span class="p">;</span>
<span class="n">swapchainCI</span><span class="p">.</span><span class="n">faceCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">swapchainCI</span><span class="p">.</span><span class="n">arraySize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">swapchainCI</span><span class="p">.</span><span class="n">mipCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">OPENXR_CHECK</span><span class="p">(</span><span class="n">xrCreateSwapchain</span><span class="p">(</span><span class="n">m_session</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">swapchainCI</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">swapchainAndDepthImage</span><span class="p">.</span><span class="n">swapchain</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Failed to create Swapchain&quot;</span><span class="p">);</span>
<span class="n">swapchainAndDepthImage</span><span class="p">.</span><span class="n">swapchainFormat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">swapchainCI</span><span class="p">.</span><span class="n">format</span><span class="p">;</span>
</pre></div>
</div>
<p>Here, we fill out the <code class="docutils literal notranslate"><span class="pre">XrSwapchainCreateInfo</span></code> structure. The <code class="docutils literal notranslate"><span class="pre">sampleCount</span></code>, <code class="docutils literal notranslate"><span class="pre">width</span></code> and <code class="docutils literal notranslate"><span class="pre">height</span></code> members can be assigned from the <code class="docutils literal notranslate"><span class="pre">XrViewConfigurationView</span></code>. We set the <code class="docutils literal notranslate"><span class="pre">createFlags</span></code> to 0 as we require no constraints or functionality. We set the <code class="docutils literal notranslate"><span class="pre">usageFlags</span></code> to <code class="docutils literal notranslate"><span class="pre">XR_SWAPCHAIN_USAGE_SAMPLED_BIT</span> <span class="pre">|</span> <span class="pre">XR_SWAPCHAIN_USAGE_COLOR_ATTACHMENT_BIT</span></code> requesting that the image are suitable to be read in a shader and to be used as a render output.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Flag bits for XrSwapchainUsageFlags</span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">XrSwapchainUsageFlags</span><span class="w"> </span><span class="n">XR_SWAPCHAIN_USAGE_COLOR_ATTACHMENT_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000001</span><span class="p">;</span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">XrSwapchainUsageFlags</span><span class="w"> </span><span class="n">XR_SWAPCHAIN_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000002</span><span class="p">;</span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">XrSwapchainUsageFlags</span><span class="w"> </span><span class="n">XR_SWAPCHAIN_USAGE_UNORDERED_ACCESS_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000004</span><span class="p">;</span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">XrSwapchainUsageFlags</span><span class="w"> </span><span class="n">XR_SWAPCHAIN_USAGE_TRANSFER_SRC_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000008</span><span class="p">;</span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">XrSwapchainUsageFlags</span><span class="w"> </span><span class="n">XR_SWAPCHAIN_USAGE_TRANSFER_DST_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000010</span><span class="p">;</span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">XrSwapchainUsageFlags</span><span class="w"> </span><span class="n">XR_SWAPCHAIN_USAGE_SAMPLED_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000020</span><span class="p">;</span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">XrSwapchainUsageFlags</span><span class="w"> </span><span class="n">XR_SWAPCHAIN_USAGE_MUTABLE_FORMAT_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000040</span><span class="p">;</span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">XrSwapchainUsageFlags</span><span class="w"> </span><span class="n">XR_SWAPCHAIN_USAGE_INPUT_ATTACHMENT_BIT_MND</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000080</span><span class="p">;</span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">XrSwapchainUsageFlags</span><span class="w"> </span><span class="n">XR_SWAPCHAIN_USAGE_INPUT_ATTACHMENT_BIT_KHR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000080</span><span class="p">;</span><span class="w">  </span><span class="c1">// alias of XR_SWAPCHAIN_USAGE_INPUT_ATTACHMENT_BIT_MND</span>
</pre></div>
</div>
<p>Below is a explanation of XrSwapchainUsageFlagBits match with the Graphics APIs.</p>
<div class="d3d11 docutils container" id="d3d11-id-1">
<p class="rubric">DirectX 11</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>XrSwapchainUsageFlagBits</p></td>
<td><p>Corresponding D3D11 bind flag bits</p></td>
</tr>
<tr class="row-even"><td><p>XR_SWAPCHAIN_USAGE_COLOR_ATTACHMENT_BIT</p></td>
<td><p>D3D11_BIND_RENDER_TARGET</p></td>
</tr>
<tr class="row-odd"><td><p>XR_SWAPCHAIN_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT</p></td>
<td><p>D3D11_BIND_DEPTH_STENCIL</p></td>
</tr>
<tr class="row-even"><td><p>XR_SWAPCHAIN_USAGE_UNORDERED_ACCESS_BIT</p></td>
<td><p>D3D11_BIND_UNORDERED_ACCESS</p></td>
</tr>
<tr class="row-odd"><td><p>XR_SWAPCHAIN_USAGE_TRANSFER_SRC_BIT</p></td>
<td><p>ignored</p></td>
</tr>
<tr class="row-even"><td><p>XR_SWAPCHAIN_USAGE_TRANSFER_DST_BIT</p></td>
<td><p>ignored</p></td>
</tr>
<tr class="row-odd"><td><p>XR_SWAPCHAIN_USAGE_SAMPLED_BIT</p></td>
<td><p>D3D11_BIND_SHADER_RESOURCE</p></td>
</tr>
<tr class="row-even"><td><p>XR_SWAPCHAIN_USAGE_MUTABLE_FORMAT_BIT</p></td>
<td><p>ignored</p></td>
</tr>
<tr class="row-odd"><td><p>XR_SWAPCHAIN_USAGE_INPUT_ATTACHMENT_BIT_KHR</p></td>
<td><p>ignored</p></td>
</tr>
</tbody>
</table>
</div>
<div class="d3d12 docutils container" id="d3d12-id-1">
<p class="rubric">DirectX 12</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>XrSwapchainUsageFlagBits</p></td>
<td><p>Corresponding D3D12 resource flag bits</p></td>
</tr>
<tr class="row-even"><td><p>XR_SWAPCHAIN_USAGE_COLOR_ATTACHMENT_BIT</p></td>
<td><p>D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET</p></td>
</tr>
<tr class="row-odd"><td><p>XR_SWAPCHAIN_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT</p></td>
<td><p>D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL</p></td>
</tr>
<tr class="row-even"><td><p>XR_SWAPCHAIN_USAGE_UNORDERED_ACCESS_BIT</p></td>
<td><p>D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS</p></td>
</tr>
<tr class="row-odd"><td><p>XR_SWAPCHAIN_USAGE_TRANSFER_SRC_BIT</p></td>
<td><p>ignored</p></td>
</tr>
<tr class="row-even"><td><p>XR_SWAPCHAIN_USAGE_TRANSFER_DST_BIT</p></td>
<td><p>ignored</p></td>
</tr>
<tr class="row-odd"><td><p>XR_SWAPCHAIN_USAGE_SAMPLED_BIT</p></td>
<td><p>D3D12_RESOURCE_FLAG_DENY_SHADER_RESOURCE</p></td>
</tr>
<tr class="row-even"><td><p>XR_SWAPCHAIN_USAGE_MUTABLE_FORMAT_BIT</p></td>
<td><p>ignored</p></td>
</tr>
<tr class="row-odd"><td><p>XR_SWAPCHAIN_USAGE_INPUT_ATTACHMENT_BIT_KHR</p></td>
<td><p>ignored</p></td>
</tr>
</tbody>
</table>
</div>
<div class="opengl docutils container" id="opengl-id-1">
<p class="rubric">OpenGL</p>
<p>All <code class="docutils literal notranslate"><span class="pre">XrSwapchainUsageFlags</span></code> are ignored as OpenGL can‚Äôt specify usage of an image.</p>
</div>
<div class="opengles docutils container" id="opengles-id-1">
<p class="rubric">OpenGL ES</p>
<p>All <code class="docutils literal notranslate"><span class="pre">XrSwapchainUsageFlags</span></code> are ignored as OpenGL ES can‚Äôt specify usage of an image.</p>
</div>
<div class="vulkan docutils container" id="vulkan-id-1">
<p class="rubric">Vulkan</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>XrSwapchainUsageFlagBits</p></td>
<td><p>Corresponding Vulkan flag bit</p></td>
</tr>
<tr class="row-even"><td><p>XR_SWAPCHAIN_USAGE_COLOR_ATTACHMENT_BIT</p></td>
<td><p>VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</p></td>
</tr>
<tr class="row-odd"><td><p>XR_SWAPCHAIN_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT</p></td>
<td><p>VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT</p></td>
</tr>
<tr class="row-even"><td><p>XR_SWAPCHAIN_USAGE_UNORDERED_ACCESS_BIT</p></td>
<td><p>VK_IMAGE_USAGE_STORAGE_BIT</p></td>
</tr>
<tr class="row-odd"><td><p>XR_SWAPCHAIN_USAGE_TRANSFER_SRC_BIT</p></td>
<td><p>VK_IMAGE_USAGE_TRANSFER_SRC_BIT</p></td>
</tr>
<tr class="row-even"><td><p>XR_SWAPCHAIN_USAGE_TRANSFER_DST_BIT</p></td>
<td><p>VK_IMAGE_USAGE_TRANSFER_DST_BIT</p></td>
</tr>
<tr class="row-odd"><td><p>XR_SWAPCHAIN_USAGE_SAMPLED_BIT</p></td>
<td><p>VK_IMAGE_USAGE_SAMPLED_BIT</p></td>
</tr>
<tr class="row-even"><td><p>XR_SWAPCHAIN_USAGE_MUTABLE_FORMAT_BIT</p></td>
<td><p>VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT</p></td>
</tr>
<tr class="row-odd"><td><p>XR_SWAPCHAIN_USAGE_INPUT_ATTACHMENT_BIT_KHR</p></td>
<td><p>VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT</p></td>
</tr>
</tbody>
</table>
</div>
<p>Next, we set the values for <code class="docutils literal notranslate"><span class="pre">faceCount</span></code>, <code class="docutils literal notranslate"><span class="pre">arraySize</span></code> and <code class="docutils literal notranslate"><span class="pre">mipCount</span></code>. <code class="docutils literal notranslate"><span class="pre">faceCount</span></code> describes the number of faces in the image and is used for creating cubemap textures. <code class="docutils literal notranslate"><span class="pre">arraySize</span></code> describes the number of layers in an image. Here, we use <code class="docutils literal notranslate"><span class="pre">1</span></code>, as we have separate swapchain per view/eye, but for a stereo view you could pass <code class="docutils literal notranslate"><span class="pre">2</span></code> and have an image 2D array, which is suitable for multiview rendering. <code class="docutils literal notranslate"><span class="pre">mipCount</span></code> describes the number of mips levels, useful when using the swapchain image as a sampled image. Finally, we can set the format. Here, we ask our <code class="docutils literal notranslate"><span class="pre">GraphicsAPIs</span></code> class to pick a suitable format for the swapachain for the enumerated format we acquired early. Here is the code for <code class="docutils literal notranslate"><span class="pre">GraphicsAPI::SelectSwapchainFormat()</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int64_t</span><span class="w"> </span><span class="nf">GraphicsAPI::SelectSwapchainFormat</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">formats</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">supportSwapchainFormats</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetSupportedSwapchainFormats</span><span class="p">();</span>

<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;::</span><span class="n">const_iterator</span><span class="w"> </span><span class="o">&amp;</span><span class="n">swapchainFormatIt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">find_first_of</span><span class="p">(</span><span class="n">formats</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">formats</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
<span class="w">                                                                                       </span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">supportSwapchainFormats</span><span class="p">),</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">supportSwapchainFormats</span><span class="p">));</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">swapchainFormatIt</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">formats</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;ERROR: Unable to find supported Swapchain Format&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">        </span><span class="n">DEBUG_BREAK</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="n">swapchainFormatIt</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The function calls a pure virtual function called <code class="docutils literal notranslate"><span class="pre">GraphicsAPI::GetSupportedSwapchainFormats()</span></code>, which each class implements. It returns an array of API-specific format us to use.</p>
<div class="d3d11 docutils container" id="id1">
<p class="rubric">DirectX 11</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">GraphicsAPI_D3D11</span><span class="o">::</span><span class="n">GetSupportedSwapchainFormats</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">DXGI_FORMAT_R8G8B8A8_UNORM</span><span class="p">,</span>
<span class="w">        </span><span class="n">DXGI_FORMAT_B8G8R8A8_UNORM</span><span class="p">,</span>
<span class="w">        </span><span class="n">DXGI_FORMAT_R8G8B8A8_UNORM_SRGB</span><span class="p">,</span>
<span class="w">        </span><span class="n">DXGI_FORMAT_B8G8R8A8_UNORM_SRGB</span><span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="d3d12 docutils container" id="id2">
<p class="rubric">DirectX 12</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">GraphicsAPI_D3D12</span><span class="o">::</span><span class="n">GetSupportedSwapchainFormats</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">DXGI_FORMAT_R8G8B8A8_UNORM</span><span class="p">,</span>
<span class="w">        </span><span class="n">DXGI_FORMAT_B8G8R8A8_UNORM</span><span class="p">,</span>
<span class="w">        </span><span class="n">DXGI_FORMAT_R8G8B8A8_UNORM_SRGB</span><span class="p">,</span>
<span class="w">        </span><span class="n">DXGI_FORMAT_B8G8R8A8_UNORM_SRGB</span><span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="opengl docutils container" id="id3">
<p class="rubric">OpenGL</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">GraphicsAPI_OpenGL</span><span class="o">::</span><span class="n">GetSupportedSwapchainFormats</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// https://github.com/KhronosGroup/OpenXR-SDK-Source/blob/f122f9f1fc729e2dc82e12c3ce73efa875182854/src/tests/hello_xr/graphicsplugin_opengl.cpp#L229-L236</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">GL_RGB10_A2</span><span class="p">,</span>
<span class="w">        </span><span class="n">GL_RGBA16F</span><span class="p">,</span>
<span class="w">        </span><span class="c1">// The two below should only be used as a fallback, as they are linear color formats without enough bits for color</span>
<span class="w">        </span><span class="c1">// depth, thus leading to banding.</span>
<span class="w">        </span><span class="n">GL_RGBA8</span><span class="p">,</span>
<span class="w">        </span><span class="n">GL_RGBA8_SNORM</span><span class="p">,</span>
<span class="w">    </span><span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="opengles docutils container" id="id4">
<p class="rubric">OpenGL ES</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">GraphicsAPI_OpenGL_ES</span><span class="o">::</span><span class="n">GetSupportedSwapchainFormats</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// https://github.com/KhronosGroup/OpenXR-SDK-Source/blob/f122f9f1fc729e2dc82e12c3ce73efa875182854/src/tests/hello_xr/graphicsplugin_opengles.cpp#L208-L216</span>
<span class="w">    </span><span class="n">GLint</span><span class="w"> </span><span class="n">glMajorVersion</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">glGetIntegerv</span><span class="p">(</span><span class="n">GL_MAJOR_VERSION</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">glMajorVersion</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">glMajorVersion</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="n">GL_RGBA8</span><span class="p">,</span><span class="w"> </span><span class="n">GL_RGBA8_SNORM</span><span class="p">,</span><span class="w"> </span><span class="n">GL_SRGB8_ALPHA8</span><span class="p">};</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="n">GL_RGBA8</span><span class="p">,</span><span class="w"> </span><span class="n">GL_RGBA8_SNORM</span><span class="p">};</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="vulkan docutils container" id="id5">
<p class="rubric">Vulkan</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">GraphicsAPI_Vulkan</span><span class="o">::</span><span class="n">GetSupportedSwapchainFormats</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">VK_FORMAT_B8G8R8A8_SRGB</span><span class="p">,</span>
<span class="w">        </span><span class="n">VK_FORMAT_R8G8B8A8_SRGB</span><span class="p">,</span>
<span class="w">        </span><span class="n">VK_FORMAT_B8G8R8A8_UNORM</span><span class="p">,</span>
<span class="w">        </span><span class="n">VK_FORMAT_R8G8B8A8_UNORM</span><span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>We call <code class="docutils literal notranslate"><span class="pre">xrCreateSwapchain()</span></code> to create our <code class="docutils literal notranslate"><span class="pre">XrSwapchain</span></code>, which, if successful, will return <code class="docutils literal notranslate"><span class="pre">XR_SUCCESS</span></code> and the <code class="docutils literal notranslate"><span class="pre">XrSwapchain</span></code> will be non-null. We copy our swapchain format to our <code class="docutils literal notranslate"><span class="pre">SwapchainAndDepthImage::swapchainFormat</span></code> for later usage.</p>
</section>
<section id="xrenumerateswapchainimages">
<h3>3.1.4 xrEnumerateSwapchainImages<a class="headerlink" href="#xrenumerateswapchainimages" title="Permalink to this heading">¬∂</a></h3>
<p>Now that we have created the <code class="docutils literal notranslate"><span class="pre">XrSwapchain</span></code>, we need to get access to the all images in the swapchain. We first call <code class="docutils literal notranslate"><span class="pre">xrEnumerateSwapchainImages()</span></code> to get the count of the images in the <code class="docutils literal notranslate"><span class="pre">XrSwapchain</span></code>. Next, we set up an array of structures to store the images from the <code class="docutils literal notranslate"><span class="pre">XrSwapchain</span></code>. In this tutorial, this array of structures, which stores the swapchains images, are stored in the <code class="docutils literal notranslate"><span class="pre">GraphicsAPI_...</span></code> class. We do this, because OpenXR will return to the application an array of structures that contain the API-specific handles to the swapchain images. <code class="docutils literal notranslate"><span class="pre">GraphicsAPI::AllocateSwapchainImageData()</span></code> is a virtual method implemented by each graphics API, which resizes an API-specific <code class="docutils literal notranslate"><span class="pre">std::vector&lt;XrSwapchainImage...KHR&gt;</span></code> and returns a pointer to the first element in that array casting it to a <code class="docutils literal notranslate"><span class="pre">XrSwapchainImageBaseHeader</span> <span class="pre">*</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">swapchainImageCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">OPENXR_CHECK</span><span class="p">(</span><span class="n">xrEnumerateSwapchainImages</span><span class="p">(</span><span class="n">swapchainAndDepthImage</span><span class="p">.</span><span class="n">swapchain</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">swapchainImageCount</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Failed to enumerate Swapchain Images.&quot;</span><span class="p">);</span>
<span class="hll"><span class="n">XrSwapchainImageBaseHeader</span><span class="w"> </span><span class="o">*</span><span class="n">swapchainImages</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">AllocateSwapchainImageData</span><span class="p">(</span><span class="n">swapchainImageCount</span><span class="p">);</span>
</span><span class="n">OPENXR_CHECK</span><span class="p">(</span><span class="n">xrEnumerateSwapchainImages</span><span class="p">(</span><span class="n">swapchainAndDepthImage</span><span class="p">.</span><span class="n">swapchain</span><span class="p">,</span><span class="w"> </span><span class="n">swapchainImageCount</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">swapchainImageCount</span><span class="p">,</span><span class="w"> </span><span class="n">swapchainImages</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Failed to enumerate Swapchain Images.&quot;</span><span class="p">);</span>
</pre></div>
</div>
<div class="d3d11 docutils container" id="id6">
<p class="rubric">DirectX 11</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">XrSwapchainImageBaseHeader</span><span class="w"> </span><span class="o">*</span><span class="nf">GraphicsAPI_D3D11::AllocateSwapchainImageData</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">count</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">swapchainImages</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">XR_TYPE_SWAPCHAIN_IMAGE_D3D11_KHR</span><span class="p">});</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">XrSwapchainImageBaseHeader</span><span class="w"> </span><span class="o">*&gt;</span><span class="p">(</span><span class="n">swapchainImages</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">swapchainImages</span></code> is of type <code class="docutils literal notranslate"><span class="pre">std::vector&lt;XrSwapchainImageD3D11KHR&gt;</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">XrSwapchainImageD3D11KHR</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="n">XrStructureType</span><span class="w">      </span><span class="n">type</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">XR_MAY_ALIAS</span><span class="w">    </span><span class="n">next</span><span class="p">;</span>
<span class="w">    </span><span class="n">ID3D11Texture2D</span><span class="o">*</span><span class="w">      </span><span class="n">texture</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">XrSwapchainImageD3D11KHR</span><span class="p">;</span>
</pre></div>
</div>
<p>The structure contains a <code class="docutils literal notranslate"><span class="pre">ID3D11Texture2D</span> <span class="pre">*</span></code> member that is the handle to one of the images in the swapchain.</p>
</div>
<div class="d3d12 docutils container" id="id7">
<p class="rubric">DirectX 12</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">XrSwapchainImageBaseHeader</span><span class="w"> </span><span class="o">*</span><span class="nf">GraphicsAPI_D3D12::AllocateSwapchainImageData</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">count</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">swapchainImages</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">XR_TYPE_SWAPCHAIN_IMAGE_D3D12_KHR</span><span class="p">});</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">XrSwapchainImageBaseHeader</span><span class="w"> </span><span class="o">*&gt;</span><span class="p">(</span><span class="n">swapchainImages</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">swapchainImages</span></code> is of type <code class="docutils literal notranslate"><span class="pre">std::vector&lt;XrSwapchainImageD3D12KHR&gt;</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">XrSwapchainImageD3D12KHR</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="n">XrStructureType</span><span class="w">      </span><span class="n">type</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">XR_MAY_ALIAS</span><span class="w">    </span><span class="n">next</span><span class="p">;</span>
<span class="w">    </span><span class="n">ID3D12Resource</span><span class="o">*</span><span class="w">       </span><span class="n">texture</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">XrSwapchainImageD3D12KHR</span><span class="p">;</span>
</pre></div>
</div>
<p>The structure contains a <code class="docutils literal notranslate"><span class="pre">ID3D12Resource</span> <span class="pre">*</span></code> member that is the handle to one of the images in the swapchain.</p>
</div>
<div class="opengl docutils container" id="id8">
<p class="rubric">OpenGL</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">XrSwapchainImageBaseHeader</span><span class="w"> </span><span class="o">*</span><span class="nf">GraphicsAPI_OpenGL::AllocateSwapchainImageData</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">count</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">swapchainImages</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">XR_TYPE_SWAPCHAIN_IMAGE_OPENGL_KHR</span><span class="p">});</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">XrSwapchainImageBaseHeader</span><span class="w"> </span><span class="o">*&gt;</span><span class="p">(</span><span class="n">swapchainImages</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">swapchainImages</span></code> is of type <code class="docutils literal notranslate"><span class="pre">std::vector&lt;XrSwapchainImageOpenGLKHR&gt;</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">XrSwapchainImageOpenGLKHR</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">XrStructureType</span><span class="w">       </span><span class="n">type</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">XR_MAY_ALIAS</span><span class="w">    </span><span class="n">next</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">              </span><span class="n">image</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">XrSwapchainImageOpenGLKHR</span><span class="p">;</span>
</pre></div>
</div>
<p>The structure contains a <code class="docutils literal notranslate"><span class="pre">uint32_t</span></code> member that is the handle to one of the images in the swapchain.</p>
</div>
<div class="opengles docutils container" id="id9">
<p class="rubric">OpenGL ES</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">XrSwapchainImageBaseHeader</span><span class="w"> </span><span class="o">*</span><span class="nf">GraphicsAPI_OpenGL_ES::AllocateSwapchainImageData</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">count</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">swapchainImages</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">XR_TYPE_SWAPCHAIN_IMAGE_OPENGL_ES_KHR</span><span class="p">});</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">XrSwapchainImageBaseHeader</span><span class="w"> </span><span class="o">*&gt;</span><span class="p">(</span><span class="n">swapchainImages</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">swapchainImages</span></code> is of type <code class="docutils literal notranslate"><span class="pre">std::vector&lt;XrSwapchainImageOpenGLESKHR&gt;</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">XrSwapchainImageOpenGLESKHR</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">XrStructureType</span><span class="w">       </span><span class="n">type</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">XR_MAY_ALIAS</span><span class="w">    </span><span class="n">next</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">              </span><span class="n">image</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">XrSwapchainImageOpenGLESKHR</span><span class="p">;</span>
</pre></div>
</div>
<p>The structure contains a <code class="docutils literal notranslate"><span class="pre">uint32_t</span></code> member that is the handle to one of the images in the swapchain.</p>
</div>
<div class="vulkan docutils container" id="id10">
<p class="rubric">Vulkan</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">XrSwapchainImageBaseHeader</span><span class="w"> </span><span class="o">*</span><span class="nf">GraphicsAPI_Vulkan::AllocateSwapchainImageData</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">count</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">swapchainImages</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">XR_TYPE_SWAPCHAIN_IMAGE_VULKAN_KHR</span><span class="p">});</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">XrSwapchainImageBaseHeader</span><span class="w"> </span><span class="o">*&gt;</span><span class="p">(</span><span class="n">swapchainImages</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">swapchainImages</span></code> is of type <code class="docutils literal notranslate"><span class="pre">std::vector&lt;XrSwapchainImageVulkanKHR&gt;</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">XrSwapchainImageVulkanKHR</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">XrStructureType</span><span class="w">       </span><span class="n">type</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">XR_MAY_ALIAS</span><span class="w">    </span><span class="n">next</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkImage</span><span class="w">               </span><span class="n">image</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">XrSwapchainImageVulkanKHR</span><span class="p">;</span>
</pre></div>
</div>
<p>The structure contains a <code class="docutils literal notranslate"><span class="pre">VkImage</span></code> member that is the handle to one of the images in the swapchain.</p>
</div>
</section>
<section id="create-depth-image-and-image-views">
<h3>3.1.5 Create Depth Image And Image Views<a class="headerlink" href="#create-depth-image-and-image-views" title="Permalink to this heading">¬∂</a></h3>
<p>Next, we create a depth image so that we can correctly render 3D perspective graphics to the view. In this tutorial, we have a <code class="docutils literal notranslate"><span class="pre">GraphicsAPI::ImageCreateInfo</span></code> structure and virtual method <code class="docutils literal notranslate"><span class="pre">GraphicsAPI::CreateImage()</span></code> that creates the API-specific objects.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">GraphicsAPI</span><span class="o">::</span><span class="n">ImageCreateInfo</span><span class="w"> </span><span class="n">depthImageCI</span><span class="p">;</span>
<span class="n">depthImageCI</span><span class="p">.</span><span class="n">dimension</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="n">depthImageCI</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">viewConfigurationView</span><span class="p">.</span><span class="n">recommendedImageRectWidth</span><span class="p">;</span>
<span class="n">depthImageCI</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">viewConfigurationView</span><span class="p">.</span><span class="n">recommendedImageRectHeight</span><span class="p">;</span>
<span class="n">depthImageCI</span><span class="p">.</span><span class="n">depth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">depthImageCI</span><span class="p">.</span><span class="n">mipLevels</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">depthImageCI</span><span class="p">.</span><span class="n">arrayLayers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">depthImageCI</span><span class="p">.</span><span class="n">sampleCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="hll"><span class="n">depthImageCI</span><span class="p">.</span><span class="n">format</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">GetDepthFormat</span><span class="p">();</span>
</span><span class="n">depthImageCI</span><span class="p">.</span><span class="n">cubemap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="n">depthImageCI</span><span class="p">.</span><span class="n">colorAttachment</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="n">depthImageCI</span><span class="p">.</span><span class="n">depthAttachment</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="n">depthImageCI</span><span class="p">.</span><span class="n">sampled</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="n">swapchainAndDepthImage</span><span class="p">.</span><span class="n">depthImage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">CreateImage</span><span class="p">(</span><span class="n">depthImageCI</span><span class="p">);</span>
</pre></div>
</div>
<p>Each graphics API overrides the virtual function <code class="docutils literal notranslate"><span class="pre">GraphicsAPI::GetDepthFormat()</span></code>, which return a API-specific image format of type <code class="docutils literal notranslate"><span class="pre">D32_F</span></code>.</p>
<div class="d3d11 docutils container" id="id11">
<p class="rubric">DirectX 11</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">int64_t</span><span class="w"> </span><span class="nf">GetDepthFormat</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="kt">int64_t</span><span class="p">)</span><span class="n">DXGI_FORMAT_D32_FLOAT</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="d3d12 docutils container" id="id12">
<p class="rubric">DirectX 12</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">int64_t</span><span class="w"> </span><span class="nf">GetDepthFormat</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="kt">int64_t</span><span class="p">)</span><span class="n">DXGI_FORMAT_D32_FLOAT</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="opengl docutils container" id="id13">
<p class="rubric">OpenGL</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">int64_t</span><span class="w"> </span><span class="nf">GetDepthFormat</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="kt">int64_t</span><span class="p">)</span><span class="n">GL_DEPTH_COMPONENT32F</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="opengles docutils container" id="id14">
<p class="rubric">OpenGL ES</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">int64_t</span><span class="w"> </span><span class="nf">GetDepthFormat</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="kt">int64_t</span><span class="p">)</span><span class="n">GL_DEPTH_COMPONENT32F</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="vulkan docutils container" id="id15">
<p class="rubric">Vulkan</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">int64_t</span><span class="w"> </span><span class="nf">GetDepthFormat</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="kt">int64_t</span><span class="p">)</span><span class="n">VK_FORMAT_D32_SFLOAT</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
</div>
<p>We store our newly created depth image in <code class="docutils literal notranslate"><span class="pre">SwapchainAndDepthImage::depthImage</span></code> for later usage when rendering.</p>
<p>Now, we create the image views: one per image in the <code class="docutils literal notranslate"><span class="pre">XrSwapchain</span></code> and an additional one for the depth image. Again in this tutorial, we have a <code class="docutils literal notranslate"><span class="pre">GraphicsAPI::ImageViewCreateInfo</span></code> structure and virtual method <code class="docutils literal notranslate"><span class="pre">GraphicsAPI::CreateImageView()</span></code> that creates the API-specific objects.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">swapchainImageCount</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">GraphicsAPI</span><span class="o">::</span><span class="n">ImageViewCreateInfo</span><span class="w"> </span><span class="n">imageViewCI</span><span class="p">;</span>
<span class="hll"><span class="w">    </span><span class="n">imageViewCI</span><span class="p">.</span><span class="n">image</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">GetSwapchainImage</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span><span class="w">    </span><span class="n">imageViewCI</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GraphicsAPI</span><span class="o">::</span><span class="n">ImageViewCreateInfo</span><span class="o">::</span><span class="n">Type</span><span class="o">::</span><span class="n">RTV</span><span class="p">;</span>
<span class="w">    </span><span class="n">imageViewCI</span><span class="p">.</span><span class="n">view</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GraphicsAPI</span><span class="o">::</span><span class="n">ImageViewCreateInfo</span><span class="o">::</span><span class="n">View</span><span class="o">::</span><span class="n">TYPE_2D</span><span class="p">;</span>
<span class="hll"><span class="w">    </span><span class="n">imageViewCI</span><span class="p">.</span><span class="n">format</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">swapchainAndDepthImage</span><span class="p">.</span><span class="n">swapchainFormat</span><span class="p">;</span>
</span><span class="w">    </span><span class="n">imageViewCI</span><span class="p">.</span><span class="n">aspect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GraphicsAPI</span><span class="o">::</span><span class="n">ImageViewCreateInfo</span><span class="o">::</span><span class="n">Aspect</span><span class="o">::</span><span class="n">COLOR_BIT</span><span class="p">;</span>
<span class="w">    </span><span class="n">imageViewCI</span><span class="p">.</span><span class="n">baseMipLevel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">imageViewCI</span><span class="p">.</span><span class="n">levelCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">imageViewCI</span><span class="p">.</span><span class="n">baseArrayLayer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">imageViewCI</span><span class="p">.</span><span class="n">layerCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">swapchainAndDepthImage</span><span class="p">.</span><span class="n">colorImageViews</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">CreateImageView</span><span class="p">(</span><span class="n">imageViewCI</span><span class="p">));</span>
<span class="p">}</span>

<span class="n">GraphicsAPI</span><span class="o">::</span><span class="n">ImageViewCreateInfo</span><span class="w"> </span><span class="n">imageViewCI</span><span class="p">;</span>
<span class="hll"><span class="n">imageViewCI</span><span class="p">.</span><span class="n">image</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">swapchainAndDepthImage</span><span class="p">.</span><span class="n">depthImage</span><span class="p">;</span>
</span><span class="n">imageViewCI</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GraphicsAPI</span><span class="o">::</span><span class="n">ImageViewCreateInfo</span><span class="o">::</span><span class="n">Type</span><span class="o">::</span><span class="n">DSV</span><span class="p">;</span>
<span class="n">imageViewCI</span><span class="p">.</span><span class="n">view</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GraphicsAPI</span><span class="o">::</span><span class="n">ImageViewCreateInfo</span><span class="o">::</span><span class="n">View</span><span class="o">::</span><span class="n">TYPE_2D</span><span class="p">;</span>
<span class="hll"><span class="n">imageViewCI</span><span class="p">.</span><span class="n">format</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">GetDepthFormat</span><span class="p">();</span>
</span><span class="n">imageViewCI</span><span class="p">.</span><span class="n">aspect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GraphicsAPI</span><span class="o">::</span><span class="n">ImageViewCreateInfo</span><span class="o">::</span><span class="n">Aspect</span><span class="o">::</span><span class="n">DEPTH_BIT</span><span class="p">;</span>
<span class="n">imageViewCI</span><span class="p">.</span><span class="n">baseMipLevel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">imageViewCI</span><span class="p">.</span><span class="n">levelCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">imageViewCI</span><span class="p">.</span><span class="n">baseArrayLayer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">imageViewCI</span><span class="p">.</span><span class="n">layerCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">swapchainAndDepthImage</span><span class="p">.</span><span class="n">depthImageView</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">CreateImageView</span><span class="p">(</span><span class="n">imageViewCI</span><span class="p">);</span>
</pre></div>
</div>
<p>Each graphics API overrides the virtual function <code class="docutils literal notranslate"><span class="pre">GraphicsAPI::GetSwapchainImage()</span></code>, which return a API-specific handle to the image, which is cast to a <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span></code>.</p>
<div class="d3d11 docutils container" id="id16">
<p class="rubric">DirectX 11</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="nf">GetSwapchainImage</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">swapchainImages</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">texture</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="d3d12 docutils container" id="id17">
<p class="rubric">DirectX 12</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="nf">GetSwapchainImage</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">        </span><span class="n">ID3D12Resource</span><span class="o">*</span><span class="w"> </span><span class="n">image</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">swapchainImages</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">texture</span><span class="p">;</span>
<span class="w">        </span><span class="n">imageStates</span><span class="p">[</span><span class="n">image</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">D3D12_RESOURCE_STATE_RENDER_TARGET</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">image</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="opengl docutils container" id="id18">
<p class="rubric">OpenGL</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="nf">GetSwapchainImage</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">swapchainImages</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">image</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="opengles docutils container" id="id19">
<p class="rubric">OpenGL ES</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="nf">GetSwapchainImage</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">swapchainImages</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">image</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="vulkan docutils container" id="id20">
<p class="rubric">Vulkan</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="nf">GetSwapchainImage</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">VkImage</span><span class="w"> </span><span class="n">image</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">swapchainImages</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">image</span><span class="p">;</span>
<span class="w">        </span><span class="n">imageStates</span><span class="p">[</span><span class="n">image</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">image</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
</pre></div>
</div>
</div>
<p>For the color image views, we use the previously stored color image format, that we used when creating the swapchain, and for the depth image view, we use the previously created depth image and the same depth format from the graphics API.
We store our newly created color image views for the swapchain in <code class="docutils literal notranslate"><span class="pre">SwapchainAndDepthImage::colorImageViews</span></code> and the depth image view in <code class="docutils literal notranslate"><span class="pre">SwapchainAndDepthImage::depthImageView</span></code> for later usage when rendering.</p>
</section>
<section id="xrdestroyswapchain">
<h3>3.1.6 xrDestroySwapchain<a class="headerlink" href="#xrdestroyswapchain" title="Permalink to this heading">¬∂</a></h3>
<p>When the main render loop has finished and the application is shutting down, we need to destroy our created <code class="docutils literal notranslate"><span class="pre">XrSwapchain</span></code>. This is done by calling <code class="docutils literal notranslate"><span class="pre">xrDestroySwapchain()</span></code> with the <code class="docutils literal notranslate"><span class="pre">XrSwapchain</span></code> and it will return <code class="docutils literal notranslate"><span class="pre">XR_SUCCESS</span></code> if successful. At the same time, we destroy the associated depth image and all of the views that the graphics API created. In this tutorial, we use <code class="docutils literal notranslate"><span class="pre">GraphicsAPI::DestroyImage()</span></code> and <code class="docutils literal notranslate"><span class="pre">GraphicsAPI::DestroyImageView()</span></code> to destroy those objects.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">DestroySwapchain</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">SwapchainAndDepthImage</span><span class="w"> </span><span class="o">&amp;</span><span class="n">swapchainAndDepthImage</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">m_swapchainAndDepthImages</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">DestroyImageView</span><span class="p">(</span><span class="n">swapchainAndDepthImage</span><span class="p">.</span><span class="n">depthImageView</span><span class="p">);</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*&amp;</span><span class="n">colorImageView</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">swapchainAndDepthImage</span><span class="p">.</span><span class="n">colorImageViews</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">DestroyImageView</span><span class="p">(</span><span class="n">colorImageView</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">DestroyImage</span><span class="p">(</span><span class="n">swapchainAndDepthImage</span><span class="p">.</span><span class="n">depthImage</span><span class="p">);</span>

<span class="w">        </span><span class="n">OPENXR_CHECK</span><span class="p">(</span><span class="n">xrDestroySwapchain</span><span class="p">(</span><span class="n">swapchainAndDepthImage</span><span class="p">.</span><span class="n">swapchain</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Failed to destroy Swapchain&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We now have <code class="docutils literal notranslate"><span class="pre">XrSwapchain</span></code> s and a depth images, ready for rendering. Next, we setup the render loop for OpenXR!</p>
</section>
</section>
<section id="building-a-renderloop">
<h2>3.2 Building a RenderLoop<a class="headerlink" href="#building-a-renderloop" title="Permalink to this heading">¬∂</a></h2>
<p>With the most of the OpenXR objects now set up, we can now turn our attention to rendering graphics. You will likely have your own rendering solution in place with things hooked up to OpenXR and ready to get going. There are two further OpenXR object that need to render; pertaining to where the user is and what the user sees of the external environment around them. Namely, these are the ‚Äòenvironment blend mode‚Äô and the ‚Äòreference space‚Äô.</p>
<p>Then, with those final pieces in place, we can look to the <code class="docutils literal notranslate"><span class="pre">RenderFrame()</span></code> and <code class="docutils literal notranslate"><span class="pre">RenderLoop()</span></code> code to invoke graphics work on the GPU and present it back to OpenXR and its compositor through the use of composition layers and within the scope of an XR Frame.</p>
<section id="xrenumerateenvironmentblendmodes">
<h3>3.2.1 xrEnumerateEnvironmentBlendModes<a class="headerlink" href="#xrenumerateenvironmentblendmodes" title="Permalink to this heading">¬∂</a></h3>
<p>Environment blend is done at the final stage after the compositor has flatten and blended all the compositing layer passed to OpenXR at the <code class="docutils literal notranslate"><span class="pre">xrEndFrame()</span></code>. The enum describes how OpenXR should blend the rendering view with the external environment behind the screen(s). The most common usages are as follows:</p>
<blockquote>
<div><ul class="simple">
<li><p>VR: <code class="docutils literal notranslate"><span class="pre">XR_ENVIRONMENT_BLEND_MODE_OPAQUE</span></code> is the most common as not all VR HMD have pass through functional either through cameras or optics. VR HMD that do have pass through can suppt other blend modes.</p></li>
<li><p>AR: <code class="docutils literal notranslate"><span class="pre">XR_ENVIRONMENT_BLEND_MODE_ADDITIVE</span></code> or <code class="docutils literal notranslate"><span class="pre">XR_ENVIRONMENT_BLEND_MODE_ALPHA_BLEND</span></code> are most common to composite rendering rendered image with external environment.</p></li>
</ul>
</div></blockquote>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>XrEnvironmentBlendMode</p></td>
<td><p>Description</p></td>
</tr>
<tr class="row-even"><td><p>XR_ENVIRONMENT_BLEND_MODE_OPAQUE</p></td>
<td><p>The composition layers will be displayed with no view of the physical world behind them.
The composited image will be interpreted as an RGB image, ignoring the composited alpha channel.</p></td>
</tr>
<tr class="row-odd"><td><p>XR_ENVIRONMENT_BLEND_MODE_ADDITIVE</p></td>
<td><p>The composition layers will be additively blended with the real world behind the display.
The composited image will be interpreted as an RGB image, ignoring the composited alpha channel during the additive blending.
This will cause black composited pixels to appear transparent.</p></td>
</tr>
<tr class="row-even"><td><p>XR_ENVIRONMENT_BLEND_MODE_ALPHA_BLEND</p></td>
<td><p>The composition layers will be alpha-blended with the real world behind the display.
The composited image will be interpreted as an RGBA image, with the composited alpha channel determining each pixel‚Äôs
level of blending with the real world behind the display.</p></td>
</tr>
</tbody>
</table>
<p><a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/html/xrspec.html#compositing">XrEnvironmentBlendMode - Enumerant Descriptions</a>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="nc">XrEnvironmentBlendMode</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">XR_ENVIRONMENT_BLEND_MODE_OPAQUE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">    </span><span class="n">XR_ENVIRONMENT_BLEND_MODE_ADDITIVE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>
<span class="w">    </span><span class="n">XR_ENVIRONMENT_BLEND_MODE_ALPHA_BLEND</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span>
<span class="w">    </span><span class="n">XR_ENVIRONMENT_BLEND_MODE_MAX_ENUM</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x7FFFFFFF</span>
<span class="p">}</span><span class="w"> </span><span class="n">XrEnvironmentBlendMode</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">GetEnvironmentBlendModes</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">environmentBlendModeSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">OPENXR_CHECK</span><span class="p">(</span><span class="n">xrEnumerateEnvironmentBlendModes</span><span class="p">(</span><span class="n">m_xrInstance</span><span class="p">,</span><span class="w"> </span><span class="n">m_systemID</span><span class="p">,</span><span class="w"> </span><span class="n">m_viewConfiguration</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">environmentBlendModeSize</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Failed to enumerate EnvironmentBlend Modes.&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">m_environmentBlendModes</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">environmentBlendModeSize</span><span class="p">);</span>
<span class="w">    </span><span class="n">OPENXR_CHECK</span><span class="p">(</span><span class="n">xrEnumerateEnvironmentBlendModes</span><span class="p">(</span><span class="n">m_xrInstance</span><span class="p">,</span><span class="w"> </span><span class="n">m_systemID</span><span class="p">,</span><span class="w"> </span><span class="n">m_viewConfiguration</span><span class="p">,</span><span class="w"> </span><span class="n">environmentBlendModeSize</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">environmentBlendModeSize</span><span class="p">,</span><span class="w"> </span><span class="n">m_environmentBlendModes</span><span class="p">.</span><span class="n">data</span><span class="p">()),</span><span class="w"> </span><span class="s">&quot;Failed to enumerate EnvironmentBlend Modes.&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="n">m_environmentBlendMode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_environmentBlendModes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="w">    </span><span class="c1">// Pick the first application supported blend mode supported by the hardware.</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">XrEnvironmentBlendMode</span><span class="w"> </span><span class="o">&amp;</span><span class="n">environmentBlendMode</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">m_applicationEnvironmentBlendModes</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">m_environmentBlendModes</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">m_environmentBlendModes</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="n">environmentBlendMode</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">m_environmentBlendModes</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">m_environmentBlendMode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">environmentBlendMode</span><span class="p">;</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We enumerate the environment blend modes as shown above. This function take a pointer to the first element in an array of <code class="docutils literal notranslate"><span class="pre">XrEnvironmentBlendMode</span></code> s as multiple environment blend modes could be available to the system. The runtime will return the array ordered by its preference for the system. After we enumerate all the <code class="docutils literal notranslate"><span class="pre">XrEnvironmentBlendMode</span></code> s, we pick the first one as an absolute default, then we loop through all our <code class="docutils literal notranslate"><span class="pre">m_environmentBlendModes</span></code> to try and find it in <code class="docutils literal notranslate"><span class="pre">m_environmentBlendModes</span></code>, which was just filled by OpenXR.</p>
</section>
<section id="xrcreatereferencespace">
<h3>3.2.2 xrCreateReferenceSpace<a class="headerlink" href="#xrcreatereferencespace" title="Permalink to this heading">¬∂</a></h3>
<p>Now that OpenXR know what the user should see, we need to tell OpenXR from where should the user by seeing. This is where the reference space comes in.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="nc">XrReferenceSpaceType</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">XR_REFERENCE_SPACE_TYPE_VIEW</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">    </span><span class="n">XR_REFERENCE_SPACE_TYPE_LOCAL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>
<span class="w">    </span><span class="n">XR_REFERENCE_SPACE_TYPE_STAGE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span>
<span class="w">    </span><span class="n">XR_REFERENCE_SPACE_TYPE_UNBOUNDED_MSFT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1000038000</span><span class="p">,</span>
<span class="w">    </span><span class="n">XR_REFERENCE_SPACE_TYPE_COMBINED_EYE_VARJO</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1000121000</span><span class="p">,</span>
<span class="w">    </span><span class="n">XR_REFERENCE_SPACE_TYPE_LOCAL_FLOOR_EXT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1000426000</span><span class="p">,</span>
<span class="w">    </span><span class="n">XR_REFERENCE_SPACE_TYPE_MAX_ENUM</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x7FFFFFFF</span>
<span class="p">}</span><span class="w"> </span><span class="n">XrReferenceSpaceType</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">CreateReferenceSpace</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">XrReferenceSpaceCreateInfo</span><span class="w"> </span><span class="n">referenceSpaceCI</span><span class="p">{</span><span class="n">XR_TYPE_REFERENCE_SPACE_CREATE_INFO</span><span class="p">};</span>
<span class="w">    </span><span class="n">referenceSpaceCI</span><span class="p">.</span><span class="n">referenceSpaceType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">XR_REFERENCE_SPACE_TYPE_LOCAL</span><span class="p">;</span>
<span class="w">    </span><span class="n">referenceSpaceCI</span><span class="p">.</span><span class="n">poseInReferenceSpace</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{{</span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">}};</span>
<span class="w">    </span><span class="n">OPENXR_CHECK</span><span class="p">(</span><span class="n">xrCreateReferenceSpace</span><span class="p">(</span><span class="n">m_session</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">referenceSpaceCI</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">m_localOrStageSpace</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Failed to create ReferenceSpace.&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>First, we fill out a <code class="docutils literal notranslate"><span class="pre">XrReferenceSpaceCreateInfo</span></code> structure. The first member is of type <code class="docutils literal notranslate"><span class="pre">XrReferenceSpaceType</span></code>.</p>
<p>When we create the <em>reference space</em>, we need to specify an <code class="docutils literal notranslate"><span class="pre">XrPosef</span></code>, which we will be the origin transform of the space. For our tutorial, we will set <code class="docutils literal notranslate"><span class="pre">XrReferenceSpaceCreateInfo::poseInReferenceSpace</span></code> to an identity, where we use an identity quaternion for the orientation and a position at the origin. If we had specified a different pose, the origin of the reference space would have been offset from the runtime‚Äôs default.</p>
<p>An <code class="docutils literal notranslate"><span class="pre">XrSpace</span></code> is a frame of reference defined not by its instantaneous values, but instead defined semantically by its purpose and relationship to other spaces. The actual, instantaneous position and orientation of an      <code class="docutils literal notranslate"><span class="pre">XrSpace</span></code> is called its <em>pose</em>.</p>
<p>One kind of reference space is view space (<code class="docutils literal notranslate"><span class="pre">XR_REFERENCE_SPACE_TYPE_VIEW</span></code>). View space is oriented with the user‚Äôs head, and is useful for user-interface and many other purposes. We don‚Äôt use it to generate view matrices for rendering, because those are often offset from the view space due to stereo rendering.</p>
<p>By using a local space (<code class="docutils literal notranslate"><span class="pre">XR_REFERENCE_SPACE_TYPE_LOCAL</span></code>), we specify that the views are relative to the XR hardware‚Äôs ‚Äòlocal‚Äô space - either the headset‚Äôs starting position or some other world-locked origin.</p>
<p>Some devices support stage space (<code class="docutils literal notranslate"><span class="pre">XR_REFERENCE_SPACE_TYPE_STAGE</span></code>); this implies a roomscale space with its origin on the floor.</p>
<p>See <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrReferenceSpaceType.html">https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrReferenceSpaceType.html</a></p>
<figure class="align-center" id="id21">
<img alt="OpenXR Reference Spaces" src="_images/OpenXRSpaces.png" />
<figcaption>
<p><span class="caption-text">Reference Spaces in OpenXR</span><a class="headerlink" href="#id21" title="Permalink to this image">¬∂</a></p>
</figcaption>
</figure>
<table class="longtable docutils align-default" id="id22">
<caption><span class="caption-text">OpenXR Reference Spaces</span><a class="headerlink" href="#id22" title="Permalink to this table">¬∂</a></caption>
<colgroup>
<col style="width: 20.0%" />
<col style="width: 60.0%" />
<col style="width: 20.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>XrReferenceSpaceType</p></th>
<th class="head"><p>Diagram</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>XR_REFERENCE_SPACE_TYPE_VIEW</p></td>
<td><figure class="align-center">
<img alt="OpenXR Reference Space View" src="_images/OpenXR-ReferenceSpace-View.png" />
</figure>
</td>
<td><p>The View Reference Space uses the view origin (or the centroid of the views in the case of stereo) as the origin of the sapce. +Y is up, +X is to the right, and -Z is forward. The space is aligned in front of the viewer and it is not gravity aligned. It is most often used for rendering small head-locked content like a HUD.</p></td>
</tr>
<tr class="row-odd"><td><p>XR_REFERENCE_SPACE_TYPE_LOCAL</p></td>
<td><figure class="align-center">
<img alt="OpenXR Reference Space Local" src="_images/OpenXR-ReferenceSpace-Local.png" />
</figure>
</td>
<td><p>The Local Reference Space uses an initial location to establish a world-locked, gravity aligned point as the origin of the sapce. +Y is up, +X is to the right, and -Z is forward. The origin is also locked for pitch(x) and roll(z). The initial position may be established at application start up or from a calibreated origin point. It is most often used for rendering seated-scale experiences such as car racing or aircraft cockpits, where a physical floor is not required. When recentering, the runtime will queue <code class="docutils literal notranslate"><span class="pre">XrEventDataReferenceSpaceChangePending</span></code> structure for the application to respond to.</p></td>
</tr>
<tr class="row-even"><td><p>XR_REFERENCE_SPACE_TYPE_STAGE</p></td>
<td><figure class="align-center">
<img alt="OpenXR Reference Space Stage" src="_images/OpenXR-ReferenceSpace-Stage.png" />
</figure>
</td>
<td><p>The Stage Reference Space defines a rectangular area that is flat and devoid of obstructions. The origin is define to be on the floor and at the center of the rectangular area. +Y is up, +X is to the right, and -Z is forward. The origin is also axis aligned to the XZ plane. It is most often used for rendering standing-scale experiences (no bounds) or room-scale experiences (with bounds) where a physical floor is required. When the user is redefining the origin or bounds of the area, the runtime will queue <code class="docutils literal notranslate"><span class="pre">XrEventDataReferenceSpaceChangePending</span></code> structure for the application to respond to.</p></td>
</tr>
</tbody>
</table>
<p><a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/html/xrspec.html#reference-spaces">7.1. Reference Spaces</a>.</p>
<p>The default coordinate system in OpenXR is right-handed with +Y up, +X to the right, and -Z forward.</p>
<figure class="align-center">
<a class="reference internal image-reference" href="_images/OpenXR-Coordinate-System.png"><img alt="OpenXR Default Coordinate System" src="_images/OpenXR-Coordinate-System.png" style="width: 50%;" /></a>
</figure>
<p>You may wish to call <code class="docutils literal notranslate"><span class="pre">xrEnumerateReferenceSpaces()</span></code> to get all <code class="docutils literal notranslate"><span class="pre">XrReferenceSpaceType</span></code> s available to the system, before choosing one that is suitable for your application and the user‚Äôs environment.</p>
</section>
<section id="renderframe">
<h3>3.2.3 RenderFrame<a class="headerlink" href="#renderframe" title="Permalink to this heading">¬∂</a></h3>
<p>In the <code class="docutils literal notranslate"><span class="pre">OpenXRTutorial</span></code> class, add the <code class="docutils literal notranslate"><span class="pre">RenderFrame()</span></code> and <code class="docutils literal notranslate"><span class="pre">RenderLayer()</span></code> methods.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">OpenXRTutorial</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">        </span><span class="c1">// [...]</span>

<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="n">Run</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="c1">// [...]</span>

<span class="w">                </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">applicationRunning</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                        </span><span class="n">PollSystemEvents</span><span class="p">();</span>
<span class="w">                        </span><span class="n">PollEvents</span><span class="p">();</span>
<span class="w">                        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sessionRunning</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                                </span><span class="n">RenderFrame</span><span class="p">();</span>
<span class="w">                        </span><span class="p">}</span>
<span class="w">                </span><span class="p">}</span>

<span class="w">                </span><span class="c1">// [...]</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="c1">// [...]</span>

<span class="k">private</span><span class="o">:</span>
<span class="w">        </span><span class="n">RenderLayer</span><span class="p">();</span>
<span class="w">        </span><span class="c1">// [...]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Below is the code needed for rendering a frame in OpenXR. Each frame, we sequence through the three primary functions <code class="docutils literal notranslate"><span class="pre">xrWaitFrame()</span></code>, <code class="docutils literal notranslate"><span class="pre">xrBeginFrame()</span></code> and <code class="docutils literal notranslate"><span class="pre">xrEndFrame()</span></code>. These functions wrap around our rendering code and communicate to the OpenXR rumtime that we are rendering and that we need to synchronize with the XR compositor‚Äôs frame hook.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">RenderFrame</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">XR_DOCS_CHAPTER_VERSION</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">XR_DOCS_CHAPTER_3_2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">XrFrameState</span><span class="w"> </span><span class="n">frameState</span><span class="p">{</span><span class="n">XR_TYPE_FRAME_STATE</span><span class="p">};</span>
<span class="w">        </span><span class="n">XrFrameWaitInfo</span><span class="w"> </span><span class="n">frameWaitInfo</span><span class="p">{</span><span class="n">XR_TYPE_FRAME_WAIT_INFO</span><span class="p">};</span>
<span class="w">        </span><span class="n">OPENXR_CHECK</span><span class="p">(</span><span class="n">xrWaitFrame</span><span class="p">(</span><span class="n">m_session</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">frameWaitInfo</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">frameState</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Failed to wait for XR Frame.&quot;</span><span class="p">);</span>

<span class="w">        </span><span class="n">XrFrameBeginInfo</span><span class="w"> </span><span class="n">frameBeginInfo</span><span class="p">{</span><span class="n">XR_TYPE_FRAME_BEGIN_INFO</span><span class="p">};</span>
<span class="w">        </span><span class="n">OPENXR_CHECK</span><span class="p">(</span><span class="n">xrBeginFrame</span><span class="p">(</span><span class="n">m_session</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">frameBeginInfo</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Failed to begin the XR Frame.&quot;</span><span class="p">);</span>

<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">rendered</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">XrCompositionLayerBaseHeader</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="n">layers</span><span class="p">;</span>
<span class="w">        </span><span class="n">XrCompositionLayerProjection</span><span class="w"> </span><span class="n">layerProjection</span><span class="p">{</span><span class="n">XR_TYPE_COMPOSITION_LAYER_PROJECTION</span><span class="p">};</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">XrCompositionLayerProjectionView</span><span class="o">&gt;</span><span class="w"> </span><span class="n">layerProjectionViews</span><span class="p">;</span>

<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">sessionActive</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">m_sessionState</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">XR_SESSION_STATE_SYNCHRONIZED</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">m_sessionState</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">XR_SESSION_STATE_VISIBLE</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">m_sessionState</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">XR_SESSION_STATE_FOCUSED</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sessionActive</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">frameState</span><span class="p">.</span><span class="n">shouldRender</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">rendered</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RenderLayer</span><span class="p">(</span><span class="n">frameState</span><span class="p">.</span><span class="n">predictedDisplayTime</span><span class="p">,</span><span class="w"> </span><span class="n">layerProjection</span><span class="p">,</span><span class="w"> </span><span class="n">layerProjectionViews</span><span class="p">);</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rendered</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">layers</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">XrCompositionLayerBaseHeader</span><span class="w"> </span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">layerProjection</span><span class="p">));</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="n">XrFrameEndInfo</span><span class="w"> </span><span class="n">frameEndInfo</span><span class="p">{</span><span class="n">XR_TYPE_FRAME_END_INFO</span><span class="p">};</span>
<span class="w">        </span><span class="n">frameEndInfo</span><span class="p">.</span><span class="n">displayTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">frameState</span><span class="p">.</span><span class="n">predictedDisplayTime</span><span class="p">;</span>
<span class="w">        </span><span class="n">frameEndInfo</span><span class="p">.</span><span class="n">environmentBlendMode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_environmentBlendMode</span><span class="p">;</span>
<span class="w">        </span><span class="n">frameEndInfo</span><span class="p">.</span><span class="n">layerCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">layers</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
<span class="w">        </span><span class="n">frameEndInfo</span><span class="p">.</span><span class="n">layers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">layers</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
<span class="w">        </span><span class="n">OPENXR_CHECK</span><span class="p">(</span><span class="n">xrEndFrame</span><span class="p">(</span><span class="n">m_session</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">frameEndInfo</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Failed to end the XR Frame.&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The primary structure in use here is the <code class="docutils literal notranslate"><span class="pre">XrFrameState</span></code>, which contains vital members for timing and rendering such <code class="docutils literal notranslate"><span class="pre">predictedDisplayTime</span></code>, which is the predicted time that the frame will be displayed to the user, and <code class="docutils literal notranslate"><span class="pre">shouldRender</span></code>, which states whether the application should render any graphics. This could occurs when the application is transitioning into or out of a running sesssion or that the system UI is focused and covering the application.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">XrFrameState</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">XrStructureType</span><span class="w">       </span><span class="n">type</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">XR_MAY_ALIAS</span><span class="w">    </span><span class="n">next</span><span class="p">;</span>
<span class="w">    </span><span class="n">XrTime</span><span class="w">                </span><span class="n">predictedDisplayTime</span><span class="p">;</span>
<span class="w">    </span><span class="n">XrDuration</span><span class="w">            </span><span class="n">predictedDisplayPeriod</span><span class="p">;</span>
<span class="w">    </span><span class="n">XrBool32</span><span class="w">              </span><span class="n">shouldRender</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">XrFrameState</span><span class="p">;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">xrBeginFrame()</span></code> and <code class="docutils literal notranslate"><span class="pre">xrEndFrame()</span></code> should ‚Äòbook-end‚Äô all the rendering in the XR frame and thus should be called as a pair. <code class="docutils literal notranslate"><span class="pre">xrBeginFrame()</span></code> should be called just before excuting any GPU work for the frame. When calling <code class="docutils literal notranslate"><span class="pre">xrEndFrame()</span></code>, we need to pass an <code class="docutils literal notranslate"><span class="pre">XrFrameEndInfo</span></code> structure to that function. We assign <code class="docutils literal notranslate"><span class="pre">XrFrameState::predictedDisplayTime</span></code> to <code class="docutils literal notranslate"><span class="pre">XrFrameEndInfo::displayTime</span></code>. It should be noted that we can modify this value during the frame. Next, we assign to <code class="docutils literal notranslate"><span class="pre">XrFrameEndInfo::environmentBlendMode</span></code> our selected environment blend mode. Last, we assign the size of and a pointer to an <code class="docutils literal notranslate"><span class="pre">std::vector&lt;XrCompositionLayerBaseHeader</span> <span class="pre">*&gt;</span></code>. These Composition Layers are used by the OpenXR compositor to create the final image for the views.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">XrFrameEndInfo</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">XrStructureType</span><span class="w">                               </span><span class="n">type</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">XR_MAY_ALIAS</span><span class="w">                      </span><span class="n">next</span><span class="p">;</span>
<span class="w">    </span><span class="n">XrTime</span><span class="w">                                        </span><span class="n">displayTime</span><span class="p">;</span>
<span class="w">    </span><span class="n">XrEnvironmentBlendMode</span><span class="w">                        </span><span class="n">environmentBlendMode</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                                      </span><span class="n">layerCount</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">XrCompositionLayerBaseHeader</span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w">    </span><span class="n">layers</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">XrFrameEndInfo</span><span class="p">;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">XrCompositionLayerBaseHeader</span></code> is the base structure from which all other <code class="docutils literal notranslate"><span class="pre">XrCompositionLayer...</span></code> types extend. They describe the type of layer to be composited along with the relevant information. If we have rendered any graphics this frame, we cast the memory address our <code class="docutils literal notranslate"><span class="pre">XrCompositionLayer...</span></code> structure to a <code class="docutils literal notranslate"><span class="pre">XrCompositionLayerBaseHeader</span> <span class="pre">*</span></code> and push it back into out <code class="docutils literal notranslate"><span class="pre">std::vector&lt;XrCompositionLayerBaseHeader</span> <span class="pre">*&gt;</span></code>, which is assigned in our <code class="docutils literal notranslate"><span class="pre">XrFrameEndInfo</span></code> structure.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">XR_MAY_ALIAS</span><span class="w"> </span><span class="n">XrCompositionLayerBaseHeader</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">XrStructureType</span><span class="w">             </span><span class="n">type</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">XR_MAY_ALIAS</span><span class="w">    </span><span class="n">next</span><span class="p">;</span>
<span class="w">    </span><span class="n">XrCompositionLayerFlags</span><span class="w">     </span><span class="n">layerFlags</span><span class="p">;</span>
<span class="w">    </span><span class="n">XrSpace</span><span class="w">                     </span><span class="n">space</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">XrCompositionLayerBaseHeader</span><span class="p">;</span>
</pre></div>
</div>
<p>Below is a table of the <code class="docutils literal notranslate"><span class="pre">XrCompositionLayer...</span></code> types provided by OpenXR 1.0 Core Specification and <code class="docutils literal notranslate"><span class="pre">XR_KHR_composition_layer_...</span></code> extensions.</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>Extension</p></td>
<td><p>Structure</p></td>
</tr>
<tr class="row-even"><td><p>OpenXR 1.0 Core Specification</p></td>
<td><p>XrCompositionLayerProjection</p></td>
</tr>
<tr class="row-odd"><td><p>OpenXR 1.0 Core Specification</p></td>
<td><p>XrCompositionLayerQuad</p></td>
</tr>
<tr class="row-even"><td><p>XR_KHR_composition_layer_cube</p></td>
<td><p>XrCompositionLayerCubeKHR</p></td>
</tr>
<tr class="row-odd"><td><p>XR_KHR_composition_layer_depth</p></td>
<td><p>XrCompositionLayerDepthInfoKHR</p></td>
</tr>
<tr class="row-even"><td><p>XR_KHR_composition_layer_cylinder</p></td>
<td><p>XrCompositionLayerCylinderKHR</p></td>
</tr>
<tr class="row-odd"><td><p>XR_KHR_composition_layer_equirect</p></td>
<td><p>XrCompositionLayerEquirectKHR</p></td>
</tr>
<tr class="row-even"><td><p>XR_KHR_composition_layer_color_scale_bias</p></td>
<td><p>XrCompositionLayerColorScaleBiasKHR</p></td>
</tr>
<tr class="row-odd"><td><p>XR_KHR_composition_layer_equirect2</p></td>
<td><p>XrCompositionLayerEquirect2KHR</p></td>
</tr>
</tbody>
</table>
<p>Other hardware vendor specific extensions relating to <code class="docutils literal notranslate"><span class="pre">XrCompositionLayer...</span></code> are also in the OpenXR 1.0 specification.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">XrSwapchainSubImage</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">XrSwapchain</span><span class="w">    </span><span class="n">swapchain</span><span class="p">;</span>
<span class="w">    </span><span class="n">XrRect2Di</span><span class="w">      </span><span class="n">imageRect</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">       </span><span class="n">imageArrayIndex</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">XrSwapchainSubImage</span><span class="p">;</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">XrCompositionLayerProjectionView</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">XrStructureType</span><span class="w">             </span><span class="n">type</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">XR_MAY_ALIAS</span><span class="w">    </span><span class="n">next</span><span class="p">;</span>
<span class="w">    </span><span class="n">XrPosef</span><span class="w">                     </span><span class="n">pose</span><span class="p">;</span>
<span class="w">    </span><span class="n">XrFovf</span><span class="w">                      </span><span class="n">fov</span><span class="p">;</span>
<span class="w">    </span><span class="n">XrSwapchainSubImage</span><span class="w">         </span><span class="n">subImage</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">XrCompositionLayerProjectionView</span><span class="p">;</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">XrCompositionLayerProjection</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">XrStructureType</span><span class="w">                            </span><span class="n">type</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">XR_MAY_ALIAS</span><span class="w">                   </span><span class="n">next</span><span class="p">;</span>
<span class="w">    </span><span class="n">XrCompositionLayerFlags</span><span class="w">                    </span><span class="n">layerFlags</span><span class="p">;</span>
<span class="w">    </span><span class="n">XrSpace</span><span class="w">                                    </span><span class="n">space</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                                   </span><span class="n">viewCount</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">XrCompositionLayerProjectionView</span><span class="o">*</span><span class="w">    </span><span class="n">views</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">XrCompositionLayerProjection</span><span class="p">;</span>
</pre></div>
</div>
<p>In this tutorial, we use the a single <code class="docutils literal notranslate"><span class="pre">XrCompositionLayerProjection</span></code>, which describes the <code class="docutils literal notranslate"><span class="pre">XrCompositionLayerFlags</span></code>, an <code class="docutils literal notranslate"><span class="pre">XrSpace</span></code> and a count and pointer to an array of <code class="docutils literal notranslate"><span class="pre">XrCompositionLayerProjectionView</span></code>.</p>
<p>The compositing of layers can be set on a per-layer basis through the use of the per-texel alpha channel. This is done throught the use of the <code class="docutils literal notranslate"><span class="pre">XrCompositionLayerFlags</span></code> member. Below is a description of these flags.</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>XrCompositionLayerFlags</p></td>
<td><p>Descriptions</p></td>
</tr>
<tr class="row-even"><td><p>XR_COMPOSITION_LAYER_CORRECT_CHROMATIC_ABERRATION_BIT</p></td>
<td><p>Enables chromatic aberration correction if not already done. It is planned to be deprecated in OpenXR 1.1</p></td>
</tr>
<tr class="row-odd"><td><p>XR_COMPOSITION_LAYER_BLEND_TEXTURE_SOURCE_ALPHA_BIT</p></td>
<td><p>Enables the layer texture‚Äôs alpha channel for blending</p></td>
</tr>
<tr class="row-even"><td><p>XR_COMPOSITION_LAYER_UNPREMULTIPLIED_ALPHA_BIT</p></td>
<td><p>States that the color channels have not been pre-multiplied with alpha for transparency</p></td>
</tr>
</tbody>
</table>
<p><a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/html/xrspec.html#composition-layer-flags">10.6.1. Composition Layer Flags</a>.</p>
<p><code class="docutils literal notranslate"><span class="pre">XrCompositionLayerProjectionView</span></code> descibes the <code class="docutils literal notranslate"><span class="pre">XrPosef</span></code> of the view relative to the reference space, the field of view of the view and to which <code class="docutils literal notranslate"><span class="pre">XrSwapchainSubImage</span></code> the view relates.</p>
<p>Before we call <code class="docutils literal notranslate"><span class="pre">RenderLayer()</span></code>, we check that the <code class="docutils literal notranslate"><span class="pre">XrSession</span></code> is active, as we don‚Äôt want to needlessly render graphics and we check whether OpenXR wants us to render.</p>
</section>
<section id="renderlayer">
<h3>3.2.4 RenderLayer<a class="headerlink" href="#renderlayer" title="Permalink to this heading">¬∂</a></h3>
<p>From the <code class="docutils literal notranslate"><span class="pre">RenderFrame()</span></code> function we call <code class="docutils literal notranslate"><span class="pre">RenderLayer()</span></code>. Here, we locate the views within the reference space, render to our swapachain images and fill out the <code class="docutils literal notranslate"><span class="pre">XrCompositionLayerProjection</span></code> and <code class="docutils literal notranslate"><span class="pre">std::vector&lt;XrCompositionLayerProjectionView&gt;</span></code> parameters.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="nf">RenderLayer</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">XrTime</span><span class="w"> </span><span class="o">&amp;</span><span class="n">predictedDisplayTime</span><span class="p">,</span><span class="w"> </span><span class="n">XrCompositionLayerProjection</span><span class="w"> </span><span class="o">&amp;</span><span class="n">layerProjection</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">XrCompositionLayerProjectionView</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">layerProjectionViews</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">XrView</span><span class="o">&gt;</span><span class="w"> </span><span class="n">views</span><span class="p">(</span><span class="n">m_viewConfigurationViews</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="w"> </span><span class="p">{</span><span class="n">XR_TYPE_VIEW</span><span class="p">});</span>

<span class="w">    </span><span class="n">XrViewState</span><span class="w"> </span><span class="n">viewState</span><span class="p">{</span><span class="n">XR_TYPE_VIEW_STATE</span><span class="p">};</span>
<span class="w">    </span><span class="n">XrViewLocateInfo</span><span class="w"> </span><span class="n">viewLocateInfo</span><span class="p">{</span><span class="n">XR_TYPE_VIEW_LOCATE_INFO</span><span class="p">};</span>
<span class="w">    </span><span class="n">viewLocateInfo</span><span class="p">.</span><span class="n">viewConfigurationType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_viewConfiguration</span><span class="p">;</span>
<span class="w">    </span><span class="n">viewLocateInfo</span><span class="p">.</span><span class="n">displayTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">predictedDisplayTime</span><span class="p">;</span>
<span class="w">    </span><span class="n">viewLocateInfo</span><span class="p">.</span><span class="n">space</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_localOrStageSpace</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">viewCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">XrResult</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xrLocateViews</span><span class="p">(</span><span class="n">m_session</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">viewLocateInfo</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">viewState</span><span class="p">,</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">views</span><span class="p">.</span><span class="n">size</span><span class="p">()),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">viewCount</span><span class="p">,</span><span class="w"> </span><span class="n">views</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">XR_SUCCESS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Failed to locate Views.&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">layerProjectionViews</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">viewCount</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">XR_TYPE_COMPOSITION_LAYER_PROJECTION_VIEW</span><span class="p">});</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">viewCount</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">imageIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="n">XrSwapchainImageAcquireInfo</span><span class="w"> </span><span class="n">acquireInfo</span><span class="p">{</span><span class="n">XR_TYPE_SWAPCHAIN_IMAGE_ACQUIRE_INFO</span><span class="p">};</span>
<span class="w">        </span><span class="n">OPENXR_CHECK</span><span class="p">(</span><span class="n">xrAcquireSwapchainImage</span><span class="p">(</span><span class="n">m_swapchainAndDepthImages</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">swapchain</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">acquireInfo</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">imageIndex</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Failed to acquire Image from the Swapchian&quot;</span><span class="p">);</span>

<span class="w">        </span><span class="n">XrSwapchainImageWaitInfo</span><span class="w"> </span><span class="n">waitInfo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">XR_TYPE_SWAPCHAIN_IMAGE_WAIT_INFO</span><span class="p">};</span>
<span class="w">        </span><span class="n">waitInfo</span><span class="p">.</span><span class="n">timeout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">XR_INFINITE_DURATION</span><span class="p">;</span>
<span class="w">        </span><span class="n">OPENXR_CHECK</span><span class="p">(</span><span class="n">xrWaitSwapchainImage</span><span class="p">(</span><span class="n">m_swapchainAndDepthImages</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">swapchain</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">waitInfo</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Failed to wait for Image from the Swapchain&quot;</span><span class="p">);</span>

<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">&amp;</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_viewConfigurationViews</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">recommendedImageRectWidth</span><span class="p">;</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">&amp;</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_viewConfigurationViews</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">recommendedImageRectHeight</span><span class="p">;</span>

<span class="w">        </span><span class="n">layerProjectionViews</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">XR_TYPE_COMPOSITION_LAYER_PROJECTION_VIEW</span><span class="p">};</span>
<span class="w">        </span><span class="n">layerProjectionViews</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pose</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">views</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pose</span><span class="p">;</span>
<span class="w">        </span><span class="n">layerProjectionViews</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">fov</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">views</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">fov</span><span class="p">;</span>
<span class="w">        </span><span class="n">layerProjectionViews</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">subImage</span><span class="p">.</span><span class="n">swapchain</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_swapchainAndDepthImages</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">swapchain</span><span class="p">;</span>
<span class="w">        </span><span class="n">layerProjectionViews</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">subImage</span><span class="p">.</span><span class="n">imageRect</span><span class="p">.</span><span class="n">offset</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="n">layerProjectionViews</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">subImage</span><span class="p">.</span><span class="n">imageRect</span><span class="p">.</span><span class="n">offset</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="n">layerProjectionViews</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">subImage</span><span class="p">.</span><span class="n">imageRect</span><span class="p">.</span><span class="n">extent</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">width</span><span class="p">);</span>
<span class="w">        </span><span class="n">layerProjectionViews</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">subImage</span><span class="p">.</span><span class="n">imageRect</span><span class="p">.</span><span class="n">extent</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">height</span><span class="p">);</span>
<span class="w">        </span><span class="n">layerProjectionViews</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">subImage</span><span class="p">.</span><span class="n">imageArrayIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">        </span><span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">BeginRendering</span><span class="p">();</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_environmentBlendMode</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">XR_ENVIRONMENT_BLEND_MODE_OPAQUE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// VR mode use a background color.</span>
<span class="w">            </span><span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">ClearColor</span><span class="p">(</span><span class="n">m_swapchainAndDepthImages</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">colorImageViews</span><span class="p">[</span><span class="n">imageIndex</span><span class="p">],</span><span class="w"> </span><span class="mf">0.22f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.17f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.35f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.00f</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// In AR mode make the background color black.</span>
<span class="w">            </span><span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">ClearColor</span><span class="p">(</span><span class="n">m_swapchainAndDepthImages</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">colorImageViews</span><span class="p">[</span><span class="n">imageIndex</span><span class="p">],</span><span class="w"> </span><span class="mf">0.00f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.00f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.00f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.00f</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">ClearDepth</span><span class="p">(</span><span class="n">m_swapchainAndDepthImages</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">depthImageView</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">);</span>

<span class="w">        </span><span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">EndRendering</span><span class="p">();</span>

<span class="w">        </span><span class="n">XrSwapchainImageReleaseInfo</span><span class="w"> </span><span class="n">releaseInfo</span><span class="p">{</span><span class="n">XR_TYPE_SWAPCHAIN_IMAGE_RELEASE_INFO</span><span class="p">};</span>
<span class="w">        </span><span class="n">OPENXR_CHECK</span><span class="p">(</span><span class="n">xrReleaseSwapchainImage</span><span class="p">(</span><span class="n">m_swapchainAndDepthImages</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">swapchain</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">releaseInfo</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Failed to release Image back to the Swapchian&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="n">layerProjection</span><span class="p">.</span><span class="n">layerFlags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">XR_COMPOSITION_LAYER_BLEND_TEXTURE_SOURCE_ALPHA_BIT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">XR_COMPOSITION_LAYER_CORRECT_CHROMATIC_ABERRATION_BIT</span><span class="p">;</span>
<span class="w">    </span><span class="n">layerProjection</span><span class="p">.</span><span class="n">space</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_localOrStageSpace</span><span class="p">;</span>
<span class="w">    </span><span class="n">layerProjection</span><span class="p">.</span><span class="n">viewCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">layerProjectionViews</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
<span class="w">    </span><span class="n">layerProjection</span><span class="p">.</span><span class="n">views</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">layerProjectionViews</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Our first call is to <code class="docutils literal notranslate"><span class="pre">xrLocateViews()</span></code>, which takes a <code class="docutils literal notranslate"><span class="pre">XrViewLocateInfo</span></code> structure and return a <code class="docutils literal notranslate"><span class="pre">XrViewState</span></code> structure and an array of <code class="docutils literal notranslate"><span class="pre">XrView</span></code> s. This functions tells us where the views are in relation to the reference space, as an <code class="docutils literal notranslate"><span class="pre">XrPosef</span></code>, as well as the field of view, as an <code class="docutils literal notranslate"><span class="pre">XrFovf</span></code>, for each view; this information is stored the <code class="docutils literal notranslate"><span class="pre">std::vector&lt;XrView&gt;</span></code>. The returned <code class="docutils literal notranslate"><span class="pre">XrViewState</span></code> contains a member of type <code class="docutils literal notranslate"><span class="pre">XrViewStateFlags</span></code>, which descibes whether the position and/or orientation is valid and/or tracked.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">XrViewLocateInfo</span></code> structure take a reference space and a display time, from which the view poses are calculated, and  takes the view configuration type to locate the correct number of view for the system. If we can‚Äôt locate the views, we return <code class="docutils literal notranslate"><span class="pre">false</span></code> from this function.</p>
<p>We resize our <code class="docutils literal notranslate"><span class="pre">std::vector&lt;XrCompositionLayerProjectionView&gt;</span></code> parameter, and for each view we render our graphics based on the acquired <code class="docutils literal notranslate"><span class="pre">XrView</span></code>. The following section is repeated for each view.</p>
<p>We now acquire an image from the swapchain to render to by calling <code class="docutils literal notranslate"><span class="pre">xrAcquireSwapchainImage()</span></code>. This returns to us an index, with which we can use to index into an array of swapchain images, or in the case of this tutorial the array of structures containing our swapachain images. Next, we call <code class="docutils literal notranslate"><span class="pre">xrWaitSwapchainImage()</span></code>, we do this avoid writing to an image that the OpenXR compositor in still reading from. The call will block the CPU thread until the swapachain image is available to use. Skipping a little bit forward to the end of the rendering of the view, we call <code class="docutils literal notranslate"><span class="pre">xrReleaseSwapchainImage()</span></code>. This call hands the swapchain image back to OpenXR for the compositor to use in create the image for the view. Like with <code class="docutils literal notranslate"><span class="pre">xrBeginFrame()</span></code> and <code class="docutils literal notranslate"><span class="pre">xrEndFrame()</span></code>, the <code class="docutils literal notranslate"><span class="pre">xr...SwapchainImage()</span></code> functions need to be called in sequence for correct API usage.</p>
<p>After we have waited for the swapachain image, before releasing it, we fill out the <code class="docutils literal notranslate"><span class="pre">XrCompositionLayerProjectionView</span></code> associated with the view and render our graphics. First, we quickly get the <code class="docutils literal notranslate"><span class="pre">width</span></code> and <code class="docutils literal notranslate"><span class="pre">height</span></code> of the view from the <code class="docutils literal notranslate"><span class="pre">XrViewConfigurationView</span></code>. We used the <code class="docutils literal notranslate"><span class="pre">recommendedImageRectWidth</span></code> and <code class="docutils literal notranslate"><span class="pre">recommendedImageRectHeight</span></code> values when creating the swapachains.</p>
<p>We can now fill out the <code class="docutils literal notranslate"><span class="pre">XrCompositionLayerProjectionView</span></code> using the <code class="docutils literal notranslate"><span class="pre">pose</span></code> and <code class="docutils literal notranslate"><span class="pre">fov</span></code> from the associated <code class="docutils literal notranslate"><span class="pre">XrView</span></code>. For the <code class="docutils literal notranslate"><span class="pre">XrSwapchainSubImage</span></code> member, we assign the <code class="docutils literal notranslate"><span class="pre">swapachain</span></code> used, the <code class="docutils literal notranslate"><span class="pre">offset</span></code> and <code class="docutils literal notranslate"><span class="pre">extent</span></code> of the render area and <code class="docutils literal notranslate"><span class="pre">imageArrayIndex</span></code>. If you are using multiview rendering and your single swapachain is comprised of 2D Array images, where each subresource layer in the image relates to a view, you can use <code class="docutils literal notranslate"><span class="pre">imageArrayIndex</span></code> to specifies the subresource layer of the image used in the rendering of this view.</p>
<p>After filling out the <code class="docutils literal notranslate"><span class="pre">XrCompositionLayerProjectionView</span></code> structure, we can use this tutorial‚Äôs <code class="docutils literal notranslate"><span class="pre">GraphicsAPI</span></code> to clear the images as a very simple test. We first call <code class="docutils literal notranslate"><span class="pre">GraphicsAPI::BeginRendering()</span></code> to setup any API-specific objects needed for rendering. Next, we call <code class="docutils literal notranslate"><span class="pre">GraphicsAPI::ClearColor()</span></code> taking the created color image view for the swapachain image; note here that we use different clear colors depending on whether our environment blend mode is opaque or otherwise. We also clear our depth image view with <code class="docutils literal notranslate"><span class="pre">GraphicsAPI::ClearDepth()</span></code>. Finally, we call <code class="docutils literal notranslate"><span class="pre">GraphicsAPI::EndRendering()</span></code> to finish the rendering then this function will submit the GPU work and wait for it to be completed.</p>
<p>Now that we have rendered both view, we fill out the <code class="docutils literal notranslate"><span class="pre">XrCompositionLayerProjection</span></code> structure, we assign our compositing flags of <code class="docutils literal notranslate"><span class="pre">XR_COMPOSITION_LAYER_BLEND_TEXTURE_SOURCE_ALPHA_BIT</span> <span class="pre">|</span> <span class="pre">XR_COMPOSITION_LAYER_CORRECT_CHROMATIC_ABERRATION_BIT</span></code> and assign our reference space. We assign to the member <code class="docutils literal notranslate"><span class="pre">viewCount</span></code> the size of the <code class="docutils literal notranslate"><span class="pre">std::vector&lt;XrCompositionLayerProjectionView&gt;</span></code> and to the member <code class="docutils literal notranslate"><span class="pre">views</span></code> a pointer to the first element in the <code class="docutils literal notranslate"><span class="pre">std::vector&lt;XrCompositionLayerProjectionView&gt;</span></code>. Finally, we return <code class="docutils literal notranslate"><span class="pre">true</span></code> from the function to state that we have successfully completed our rendering.</p>
<p>We should now have clear colors rendered to each view in your XR system. From here, you can easily expand the graphical complexity of the scene. In the next chapter, we will discuss how to use OpenXR to interact with your XR application enabling new experiences in spatial computing.</p>
</section>
</section>
</section>


						</div>
					</div>
					<footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="2-setup.html" class="btn btn-neutral float-left" title="‚öôÔ∏è 2 Setup" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="4-actions.html" class="btn btn-neutral float-right" title="üïπ 4 Interactions" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr>

  <div role="contentinfo">
    <p>&#169; Copyright &#34;OpenXR&#34; and the OpenXR logo are trademarks owned by The Khronos Group Inc. and are registered as a trademark in China, the European Union, Japan and the United Kingdom.</p>
  </div> 

</footer>
				</div>
			</div>
		</div>
	</div>
  <script></script> 

</body>
</html>