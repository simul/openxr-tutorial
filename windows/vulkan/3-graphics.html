<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
	<meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta content="OpenXR Tutorial: Graphics" name="description" />
<meta content="khronos, openxr, tutorial, graphics" name="keywords" />

	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>3 Graphics &mdash; OpenXR Tutorial  documentation</title>
	<link rel="stylesheet" href="_static/pygments.css" type="text/css">
	<link rel="stylesheet" href="_static/css/theme.css" type="text/css">
	<link rel="stylesheet" href="_static/copybutton.css" type="text/css">
	<link rel="shortcut icon" href="_static/favicon.ico">
	<link rel="canonical" href="https://openxr-tutorial.simul.co/3-graphics.html" >
	<!--[if lt IE 9]>
	  <script src="_static/js/html5shiv.min.js"></script>
	<![endif]-->
	
	<script src="_static/jquery.js?v=5d32c60e"></script>
	<script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
	<script src="_static/documentation_options.js?v=5929fcd5"></script>
	<script src="_static/doctools.js?v=888ff710"></script>
	<script src="_static/sphinx_highlight.js?v=dc90522c"></script>
	<script src="_static/clipboard.min.js?v=a7894cd8"></script>
	<script src="_static/copybutton.js?v=f281be69"></script>
	<script src="https://unpkg.com/mermaid@9.4.0/dist/mermaid.min.js"></script>
	<script>mermaid.initialize({startOnLoad:true});</script>
	<script src="_static/js/theme.js"></script>
	<link rel="index" title="Index" href="genindex.html" >
	<link rel="search" title="Search" href="search.html" >
	<link rel="next" title="4 Interactions" href="4-actions.html" >
	<link rel="prev" title="2 OpenXR Setup" href="2-setup.html" > 
	<script  src="_static/js/js.cookie.min.js"></script>
	<script >
	var currentPlatform="all";
	var currentAPI="all";
	function setPlatform(pl)
	{
		currentPlatform=pl;
		if(navigator.cookieEnabled)
			Cookies.set('platform', pl, { expires: 365,sameSite: "strict"});
	}
	function setGraphicsAPI(a)
	{
		currentAPI=a;
		if(navigator.cookieEnabled)
			Cookies.set('graphicsapi', a, { expires: 365,sameSite: "strict"});
	}
	function getPlatform()
	{
		if(currentPlatform=="all"&&navigator.cookieEnabled)
		{
			currentPlatform=Cookies.get("platform");
			if (typeof currentPlatform == 'undefined')
			{
				currentPlatform = "windows"; // Default if cookies are enabled.
			//	console.log("getPlatform() defaulted to: "+currentPlatform);
			}
			//else
			//	console.log("getPlatform() from cookie: "+currentPlatform);
		}
		//console.log("getPlatform() returned: "+currentPlatform);
		return currentPlatform;
	}
	function getGraphicsAPI()
	{
		if(currentAPI=="all"&&navigator.cookieEnabled)
		{
			currentAPI=Cookies.get("graphicsapi");
			if (typeof currentAPI == 'undefined')
			{
				currentAPI = "vulkan"; // Default if cookies are enabled.
				//console.log("getGraphicsAPI() defaulted to: "+currentAPI);
			}
			//else
			//	console.log("getGraphicsAPI() from cookie: "+currentAPI);
		}
		//console.log("getGraphicsAPI() returned: "+currentAPI);
		return currentAPI;
	}


	//https://stackoverflow.com/questions/8562613/how-to-add-url-parameter-to-the-current-url
	function addUrlParameter(addr,name, value)
	{
		//console.log("add url parameter to : "+addr)
		url=new URL(addr);
		url.searchParams.set(name,value);
		return url.toString();
	}

	function getUrlParameter(name)
	{
		const urlParams = new URLSearchParams(window.location.search);
		return urlParams.get(name);
	}

	function getUrlParameterWithCheck(name, checkValues, defaultValue)
	{
		const urlParameter = getUrlParameter(name);
		ok = false;
		for (i = 0; i < checkValues.length; i++)
		{
			ok |= (urlParameter == checkValues[i]);
		}
		return ok ? urlParameter : defaultValue;
	}

	function updatePlatformFromURL()
	{
		var platform = getUrlParameterWithCheck('platform', ['windows', 'linux', 'android'], getPlatform());
		if (typeof platform == 'undefined')
		{
			platform = "linux"; // Set default here.
		}
		setPlatform(platform);
		updatePlatform();
	}

	function updatePlatformFromTab()
	{
		var platform = getPlatform();
		if (typeof platform == 'undefined')
		{
			platform = "linux"; // Set default here.
		}
		setPlatform(platform);
		updatePlatform();
	}

	function updatePlatform()
	{
		var platform = getPlatform();
		console.log('updatePlatform() = ' + platform);
		$(".linux").hide();
		$(".android").hide();
		$(".windows").hide();
		if (platform == "windows"||platform == "all")
		{
		$(".windows").show();
			$(".selectd3d11").removeAttr("disabled");
			$(".selectd3d12").removeAttr("disabled");
			$(".selectopengles").attr("disabled", true);
			$(".selectvulkan").removeAttr("disabled");
			$(".selectopengl").removeAttr("disabled");
		}
		if (platform == "linux"||platform == "all")
		{
			$(".linux").show();
			$(".selectd3d11").attr("disabled", true);
			$(".selectd3d12").attr("disabled", true);
			$(".selectopengles").attr("disabled", true);
			$(".selectvulkan").removeAttr("disabled");
			$(".selectopengl").removeAttr("disabled");
		}
		if (platform == "android"||platform == "all")
		{
			//console.log("platform  " + platform + ".");
			$(".android").show();
			$(".selectd3d11").attr("disabled", true);
			$(".selectd3d12").attr("disabled", true);
			$(".selectopengles").removeAttr("disabled");
			$(".selectvulkan").removeAttr("disabled");
			$(".selectopengl").attr("disabled", true);
		}
		var oldelements = document.querySelectorAll(".selected-platform");
		while (oldelements.length > 0)
		{
			var el=oldelements.item(0);
			el.classList.remove('selected-platform');
			////console.log("Removing selected-platform from "+el.id);
			oldelements = document.querySelectorAll(".selected-platform");
		}
		var element = document.getElementById('select' + platform);
		if(element)
		{
			element.classList.add('selected-platform');
		////console.log("Adding selected-platform to "+element.id);
		}
		var element2 = document.getElementById('select' + platform + "-inline");
		if(element2)
		{
			element2.classList.add('selected-platform');
		////console.log("Adding selected-platform to "+element2.id);
		}
		if(limitAPIChoice())
			updateGraphicsAPI();
		window.updatePlatform=updatePlatform;
	}

	function limitAPIChoice()
	{
		var platform = getPlatform();
		var graphicsApi = getGraphicsAPI();
		////console.log("limitAPIChoice(), platform = " + platform+", graphicsApi = "+graphicsApi);
		window.limitAPIChoice=limitAPIChoice;
		var newApi=graphicsApi;
		if (platform == "windows")
		{
			if (graphicsApi == "opengles"||graphicsApi==undefined)
			newApi="d3d11";
		}
		if (platform == "linux")
		{
			if (graphicsApi == "opengles"||graphicsApi=="d3d11"||graphicsApi=="d3d12"||graphicsApi==undefined)
			newApi="vulkan";
		}
		if (platform == "android"||graphicsApi==undefined)
		{
			if (graphicsApi != "opengles"&&graphicsApi!="vulkan")
			newApi="vulkan";
		}
		////console.log("newApi = "+newApi);
		if (newApi != graphicsApi)
		{
			////console.log("setting graphicsapi = "+newApi);
			setGraphicsAPI(newApi);
			graphicsApi=newApi;
			return true;
		}
		return false;
	}
	function makeLinksOpenInNewWindow()
	{
		////console.log("makeLinksOpenInNewWindow ");
		var download_hrefs = document.getElementsByClassName('reference download internal');
		[].forEach.call(download_hrefs, function(el) {
			el.setAttribute('target', "_blank");
			////console.log("Adding target blank to "+el.id);
		});
		link_hrefs = document.getElementsByClassName('reference external');
		[].forEach.call(link_hrefs, function(el) {
			// ONLY if it's really an external link, i.e. it contains "http:" or "https:"
			if(el.getAttribute('href').includes("://")) {
				console.log(el.getAttribute('href')+" includes ://");
				el.setAttribute('target', "_blank");
			}
			else {
			}
			////console.log("Adding target blank to "+el.id);
		});
		window.makeLinksOpenInNewWindow=makeLinksOpenInNewWindow;
	}
	function initDropdownLinks()
	{
		//console.log("initDropdownLinks ");
		var platform_api_links = document.getElementsByClassName('dropdown-platform-api');
		//let pattern = new RegExp("\/[windows|linux|android]\/[d3d11|d3d12|vulkan|opengl|opengles]\/","gm");
		let pattern = new RegExp("(windows|linux|android)\/(d3d11|d3d12|vulkan|opengles|opengl)","gm");
		let root_pattern = new RegExp("(.*)\/([a-z0-9A-Z_]+\.html)","gm");
		[].forEach.call(platform_api_links, function(el) {
			href=window.location.href;
			//console.log("href "+href);
			platform_api=el.id.replace('-','/');
			//console.log("platform_api "+platform_api);
			if(href.match(pattern)==null)
			{
				href=href.replace(root_pattern,"$1/"+platform_api+"/$2");
			}
			else
			{
				href=href.replace(pattern, platform_api);
			}
			//console.log("-> href "+href);
			el.href=href;
			////console.log("Adding target blank to "+el.id);
		});
		window.initDropdownLinks=initDropdownLinks;
	}
	function addIconsToToctree()
	{
		var toctreeheadings = document.getElementsByClassName('toctree-l1');
		var i = 0;
		const heading_ids = ["toc_introduction", "toc_setup", "toc_graphics","toc_interactions","toc_extensions","toc_nextsteps"];
		const heading_anchors = ["introduction", "openxr-setup", "graphics","interactions","extensions","nextsteps"];
		[].forEach.call(toctreeheadings, function(el) {
			if(i<6) {
				el.id =heading_ids[i];
				el.classList.add('toctree-sidepanel');
				el.children[0].href=el.children[0].href.replace('#','')+"#"+heading_anchors[i];
			}
			i++;
		////console.log("Adding id "+heading_ids[i]+" to toctree heading "+i);
		});
	}
	function copyLinkToThisPage()
	{
		var graphicsapi =getGraphicsAPI();
		var platform	=getPlatform();
		var url			=window.location.href;
		url				=addUrlParameter(url,"platform",platform);
		url				=addUrlParameter(url,"graphicsapi",graphicsapi);
		navigator.clipboard.writeText(url);
		var dlg = document.getElementById("copied-link-dialog");
		document.getElementById("copied-link-text").innerHTML  = "Copied:<br>" + url + "<br>to the clipboard.";
		dlg.style.visibility = 'visible';
		var sharepagetooltip = document.getElementById('share-page-tooltiptext');
		//sharepagetooltip.style.opacity = 0;
		setTimeout(() =>
		{
		const dlg = document.getElementById("copied-link-dialog");
		dlg.style.visibility = 'hidden';
		}, 2500);

	// Alert the copied text
	//alert("Copied the link: " + url+" to the clipboard.");
	}
	function updateGraphicsAPIFromURL()
	{
		var graphicsApi = getUrlParameterWithCheck('graphicsapi', ['d3d11', 'd3d12', 'opengl', 'opengles', 'vulkan'], getGraphicsAPI());
		setGraphicsAPI(graphicsApi);
		updateGraphicsAPI();
	}

	function updateGraphicsAPIFromTab()
	{
		var graphicsApi = getGraphicsAPI();
		if (typeof graphicsApi == 'undefined')
		{
			graphicsApi = "vulkan"; // Set default here.
		}
		setGraphicsAPI(graphicsApi);
		updateGraphicsAPI();
	}

	function updateGraphicsAPI()
	{
		var graphicsApi = getGraphicsAPI();
		//console.log('updateGraphicsAPI() = ' + graphicsApi);

		// first, hide all the api's
		$(".d3d11").hide();
		$(".d3d12").hide();
		$(".opengl").hide();
		$(".opengles").hide();
		$(".vulkan").hide();
		// Now, show the wanted api's. In this way, divs with more than one will be shown, even if they have one that is hidden.
		if (graphicsApi == "d3d11"||graphicsApi == "all") {
		$(".d3d11").show();
		}
		if (graphicsApi == "d3d12"||graphicsApi == "all") {
		$(".d3d12").show();
		}
		if (graphicsApi == "opengl"||graphicsApi == "all") {
		$(".opengl").show();
		}
		if (graphicsApi == "opengles"||graphicsApi == "all") {
		$(".opengles").show();
		}
		if (graphicsApi == "vulkan"||graphicsApi == "all") {
		$(".vulkan").show();
		}
			var oldelements = document.querySelectorAll(".selected-graphics-api");
			////console.log("selected-platform on "+oldelements.length+" elements.");
			while (oldelements.length > 0)
			{
				var el=oldelements.item(0);
				el.classList.remove('selected-graphics-api');
				////console.log("Removing selected-graphics-api from "+el.id);
				oldelements = document.querySelectorAll(".selected-graphics-api");
			}
			var element = document.getElementById('select' + graphicsApi);
			if(element)
			{
				element.classList.add('selected-graphics-api');
			}
			var element2 = document.getElementById('select' + graphicsApi +"-inline");
			if (element2)
			{
				element2.classList.add('selected-graphics-api');
			}
			window.updateGraphicsAPI=updateGraphicsAPI;
		}</script>
		<script >
		var graphicsApi = getGraphicsAPI();
		if (graphicsApi==undefined) {
			setGraphicsAPI(a);
			graphicsApi='vulkan';
		}
	</script>
	<style>
	@import url('https://fonts.googleapis.com/css2?family=Poppins&display=swap');
	@import url('https://fonts.cdnfonts.com/css/menlo');
	</style>
</head>

<body class="wy-body-for-nav" onpageshow="updatePlatformFromURL(); updateGraphicsAPIFromURL();initDropdownLinks()" onload="makeLinksOpenInNewWindow(); addIconsToToctree();"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
			<a href="/"  class="" >
				<img src="_static/OpenXR_170px_Feb17.png" class="logo" alt="The OpenXR logo" >
				
				<span class="sidebartitle">
					Tutorial
				</span>
				
			</a>
<div role="search">
    <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
        <label class="search-label" for="q">Search the tutorial</label>
        <input type="text" name="q" id="q" placeholder="Search..." aria-label="Search docs">
        <input type="hidden" name="check_keywords" value="yes">
        <input type="hidden" name="area" value="default">
    </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!--<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="1-introduction.html">1 Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="2-setup.html">2 OpenXR Setup</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">3 Graphics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#creating-swapchains">3.1 Creating Swapchains</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#view-configurations">3.1.1 View Configurations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#enumerate-the-swapchain-formats">3.1.2 Enumerate the Swapchain Formats</a></li>
<li class="toctree-l3"><a class="reference internal" href="#create-the-swapchains">3.1.3 Create the Swapchains</a></li>
<li class="toctree-l3"><a class="reference internal" href="#enumerate-swapchain-images">3.1.4 Enumerate Swapchain Images</a></li>
<li class="toctree-l3"><a class="reference internal" href="#create-the-swapchain-image-views">3.1.5 Create the Swapchain Image Views</a></li>
<li class="toctree-l3"><a class="reference internal" href="#destroy-the-swapchain">3.1.6 Destroy the Swapchain</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#building-a-renderloop">3.2 Building a RenderLoop</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#environment-blend-modes">3.2.1 Environment Blend Modes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#reference-spaces">3.2.2 Reference Spaces</a></li>
<li class="toctree-l3"><a class="reference internal" href="#rendering-a-frame">3.2.3 Rendering a Frame</a></li>
<li class="toctree-l3"><a class="reference internal" href="#rendering-layers">3.2.4 Rendering Layers</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rendering-cuboids">3.3 Rendering Cuboids</a></li>
<li class="toctree-l2"><a class="reference internal" href="#summary">3.4 Summary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="4-actions.html">4 Interactions</a></li>
<li class="toctree-l1"><a class="reference internal" href="5-extensions.html">5 Extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="6-next-steps.html">6 Next Steps</a></li>
</ul>
-->
			<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
			<ul>
				<li class="toctree-l1"><a class="reference internal" href="/windows/vulkan/1-introduction.html">1 Introduction</a></li>
				<li class="toctree-l1"><a class="reference internal" href="/windows/vulkan/2-setup.html">2 OpenXR Setup</a></li>
				<li class="toctree-l1"><a class="reference internal" href="/windows/vulkan/3-graphics.html">3 Graphics</a></li>
				<li class="toctree-l1"><a class="reference internal" href="/windows/vulkan/4-actions.html">4 Interactions</a></li>
				<li class="toctree-l1"><a class="reference internal" href="/windows/vulkan/5-extensions.html">5 Extensions</a></li>
				<li class="toctree-l1"><a class="reference internal" href="/windows/vulkan/6-next-steps.html">6 Next Steps</a></li>
			</ul>
        </div>
      </div>
    </nav>

	<div data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
			<i data-toggle="wy-nav-top" class="fa fa-bars"></i>
			<a href="index.html">OpenXR Tutorial</a>
		</nav>

		<div class="sticky-breadcrumb-ribbon" role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">3 Graphics</li>
	  <li class="wy-breadcrumbs-aside">
		  ﻿

<div class="platform-api-dropdown">
  <span>Windows/Vulkan</span>
  <div class="platform-api-dropdown-content">
    <ul>
      <li><a class="dropdown-platform-api" id="android-opengles" href="#">Android OpenGL ES</a></li>
      <li><a class="dropdown-platform-api" id="android-vulkan" href="#">Android Vulkan</a></li>
      <li><a class="dropdown-platform-api" id="linux-opengl" href="#">Linux OpenGL</a></li>
      <li><a class="dropdown-platform-api" id="linux-vulkan" href="#">Linux Vulkan</a></li>
      <li><a class="dropdown-platform-api" id="windows-d3d11" href="#">Windows D3D11</a></li>
      <li><a class="dropdown-platform-api" id="windows-d3d12" href="#">Windows D3D12</a></li>
      <li><a class="dropdown-platform-api" id="windows-opengl" href="#">Windows OpenGL</a></li>
      <li><a class="dropdown-platform-api" id="windows-vulkan" href="#">Windows Vulkan</a></li>
    </ul>
  </div>
</div>



<script>
	function choosePlatform(platformName)
	{
		setPlatform(platformName);
		updatePlatformFromTab();
	};
</script>

<script>
	function chooseGraphicsAPI(graphicsApiName)
	{
		setGraphicsAPI(graphicsApiName);
		updateGraphicsAPIFromTab();
		limitAPIChoice();
	};
</script>
	  </li>
  </ul>
</div>
		<div class="wy-nav-content">
				<div class="rst-content">
					<div class="share-page-container">
						<button class="share-this-page" id='share-this-page' onclick="copyLinkToThisPage()">
							<img class="api-tab-img" src="_static/css/icons/share_FILL0_wght400_GRAD0_opsz24.svg" alt="Copy link to this page" />
						</button>
						<div id="copied-link-dialog">
							<p id="copied-link-text"></p>
						</div>
						<div id="share-page-tooltiptext">Copy link to this page</div>
</div>
				<div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
					<div itemprop="articleBody">
						
  <section id="graphics">
<h1>3 Graphics<a class="headerlink" href="#graphics" title="Link to this heading">¶</a></h1>
<p>The goal of this chapter is to build an application that creates and clears color and depth buffers and draws some geometry to the views within the scope of OpenXR render loop and to demonstrate its interaction with the Graphics APIs.</p>
<p>In the <em>workspace</em> directory, update the <code class="docutils literal notranslate"><span class="pre">CMakeLists.txt</span></code> by adding the following CMake code to the end of the file:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">add_subdirectory</span><span class="p">(</span><span class="s">Chapter3</span><span class="p">)</span>
</pre></div>
</div>
<p>Now, create a <code class="docutils literal notranslate"><span class="pre">Chapter3</span></code> folder in the <em>workspace</em> directory and into that folder copy the <code class="docutils literal notranslate"><span class="pre">main.cpp</span></code> and <code class="docutils literal notranslate"><span class="pre">CMakeLists.txt</span></code> from <code class="docutils literal notranslate"><span class="pre">Chapter2</span></code>. In the <code class="docutils literal notranslate"><span class="pre">Chapter3/CMakeLists.txt</span></code> update these lines:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span><span class="w"> </span><span class="s">3.22.1</span><span class="p">)</span>
<span class="nb">set</span><span class="p">(</span><span class="s">PROJECT_NAME</span><span class="w"> </span><span class="s">OpenXRTutorialChapter3</span><span class="p">)</span>
<span class="nb">project</span><span class="p">(</span><span class="s2">&quot;${PROJECT_NAME}&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Create a <code class="docutils literal notranslate"><span class="pre">Shaders</span></code> folder in your root <em>workspace</em> folder, download and put these files in it:</p>
<ul class="simple">
<li><p><a class="reference download internal" download="" href="_downloads/87f4ebe3fd83fe1bc3cf07b57229857c/VertexShader.glsl"><code class="xref download docutils literal notranslate"><span class="pre">Shaders/VertexShader.glsl</span></code></a></p></li>
<li><p><a class="reference download internal" download="" href="_downloads/40bc9855ab807d86043fec89482838b9/PixelShader.glsl"><code class="xref download docutils literal notranslate"><span class="pre">Shaders/PixelShader.glsl</span></code></a></p></li>
</ul>
<p>Underneath the <code class="docutils literal notranslate"><span class="pre">SOURCES</span></code> and <code class="docutils literal notranslate"><span class="pre">HEADERS</span></code> section, add the following CMake code specifying the location of the shaders:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">set</span><span class="p">(</span><span class="s">GLSL_SHADERS</span>
<span class="w">    </span><span class="s2">&quot;../Shaders/VertexShader.glsl&quot;</span>
<span class="w">    </span><span class="s2">&quot;../Shaders/PixelShader.glsl&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Underneath section where specify your Graphics API, add the following CMake code:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="c"># Vulkan GLSL</span>
<span class="nb">set</span><span class="p">(</span><span class="s">SHADER_DEST</span><span class="w"> </span><span class="s2">&quot;${CMAKE_CURRENT_BINARY_DIR}&quot;</span><span class="p">)</span>
<span class="nb">if</span><span class="w"> </span><span class="p">(</span><span class="s">Vulkan_FOUND</span><span class="p">)</span>
<span class="w">    </span><span class="nb">include</span><span class="p">(</span><span class="s">glsl_shader</span><span class="p">)</span>
<span class="w">    </span><span class="nb">set_source_files_properties</span><span class="p">(</span><span class="s">../Shaders/VertexShader.glsl</span><span class="w"> </span><span class="s">PROPERTIES</span><span class="w"> </span><span class="s">ShaderType</span><span class="w"> </span><span class="s2">&quot;vert&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="nb">set_source_files_properties</span><span class="p">(</span><span class="s">../Shaders/PixelShader.glsl</span><span class="w"> </span><span class="s">PROPERTIES</span><span class="w"> </span><span class="s">ShaderType</span><span class="w"> </span><span class="s2">&quot;frag&quot;</span><span class="p">)</span>

<span class="w">    </span><span class="nb">foreach</span><span class="p">(</span><span class="s">FILE</span><span class="w"> </span><span class="o">${</span><span class="nv">GLSL_SHADERS</span><span class="o">}</span><span class="p">)</span>
<span class="w">        </span><span class="nb">get_filename_component</span><span class="p">(</span><span class="s">FILE_WE</span><span class="w"> </span><span class="o">${</span><span class="nv">FILE</span><span class="o">}</span><span class="w"> </span><span class="s">NAME_WE</span><span class="p">)</span>
<span class="w">        </span><span class="nb">get_source_file_property</span><span class="p">(</span><span class="s">shadertype</span><span class="w"> </span><span class="o">${</span><span class="nv">FILE</span><span class="o">}</span><span class="w"> </span><span class="s">ShaderType</span><span class="p">)</span>
<span class="w">        </span><span class="nb">glsl_spv_shader</span><span class="p">(</span>
<span class="w">           </span><span class="s">INPUT</span><span class="w"> </span><span class="s2">&quot;${CMAKE_CURRENT_SOURCE_DIR}/${FILE}&quot;</span>
<span class="w">           </span><span class="s">OUTPUT</span><span class="w"> </span><span class="s2">&quot;${SHADER_DEST}/${FILE_WE}.spv&quot;</span>
<span class="w">           </span><span class="s">STAGE</span><span class="w"> </span><span class="o">${</span><span class="nv">shadertype</span><span class="o">}</span>
<span class="w">           </span><span class="s">ENTRY_POINT</span><span class="w"> </span><span class="s">main</span>
<span class="w">           </span><span class="s">TARGET_ENV</span><span class="w"> </span><span class="s">vulkan1.0</span>
<span class="w">        </span><span class="p">)</span>
<span class="w">        </span><span class="c"># Make our project depend on these files</span>
<span class="w">        </span><span class="nb">target_sources</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span><span class="w"> </span><span class="s">PRIVATE</span><span class="w"> </span><span class="s2">&quot;${SHADER_DEST}/${FILE_WE}.spv&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="nb">endforeach</span><span class="p">()</span>
<span class="nb">endif</span><span class="p">()</span>
</pre></div>
</div>
<section id="creating-swapchains">
<h2>3.1 Creating Swapchains<a class="headerlink" href="#creating-swapchains" title="Link to this heading">¶</a></h2>
<p>As with rendering graphics to a 2D display, OpenXR uses the concept of swapchains. It’s a series of images that are used to present the rendered graphics to display/window/view. There are usually 2 or 3 images in the swapchain to allow the platform to present them smoothly to the user in order to create the illusion of motion within the image.</p>
<p>All graphics APIs have the concept of a swapchain with varying levels of exposure in the API. For OpenXR development, you will not create the API-specific swapchain. Instead, we use OpenXR to create swapchains and the OpenXR compositor, which is part on an XR runtime, to present rendered graphics to the views. XR applications are unique in that often have multiple views that need to be rendered to create the XR experience. Listed below are a couple of scenarios with differing view counts:</p>
<blockquote>
<div><ul class="simple">
<li><p>1 view  - Viewer on a phone, tablet or monitor.</p></li>
<li><p>2 views - Stereoscopic headset.</p></li>
</ul>
</div></blockquote>
<p>Orthogonal to multiple views is the layering of multiple images. You could, for example, have a background that is a pass-through of your environment, a stereoscopic view of rendered graphics and a quadrilateral overlay of a HUD (Head-up display) or UI elements; all of of which could have different spatial orientations. This layering of views is handled by the XR compositor to composite correctly the layers for each view - that quad overlay might be behind the user, and thus shouldn’t be rendered to the eye views. Composition layers will be discussed later in <a class="reference internal" href="#rendering-a-frame"><span class="std std-ref">Chapter 3.2.3</span></a>.</p>
<p>Firstly, we will update the class in the <code class="docutils literal notranslate"><span class="pre">Chapter3/main.cpp</span></code> to add the new methods and members. Copy the highlighted code below.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">OpenXRTutorial</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">        </span><span class="c1">// [...] Constructor and Destructor created in previous chapters.</span>

<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="n">Run</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">CreateInstance</span><span class="p">();</span>
<span class="w">                </span><span class="n">CreateDebugMessenger</span><span class="p">();</span>

<span class="w">                </span><span class="n">GetInstanceProperties</span><span class="p">();</span>
<span class="w">                </span><span class="n">GetSystemID</span><span class="p">();</span>

<span class="hll"><span class="w">                </span><span class="n">GetViewConfigurationViews</span><span class="p">();</span>
</span>
<span class="w">                </span><span class="n">CreateSession</span><span class="p">();</span>
<span class="hll"><span class="w">                </span><span class="n">CreateSwapchains</span><span class="p">();</span>
</span>
<span class="w">                </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">m_applicationRunning</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                        </span><span class="n">PollSystemEvents</span><span class="p">();</span>
<span class="w">                        </span><span class="n">PollEvents</span><span class="p">();</span>
<span class="w">                        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_sessionRunning</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                                </span><span class="c1">// Draw Frame.</span>
<span class="w">                        </span><span class="p">}</span>
<span class="w">                </span><span class="p">}</span>

<span class="hll"><span class="w">                </span><span class="n">DestroySwapchains</span><span class="p">();</span>
</span><span class="w">                </span><span class="n">DestroySession</span><span class="p">();</span>

<span class="w">                </span><span class="n">DestroyDebugMessenger</span><span class="p">();</span>
<span class="w">                </span><span class="n">DestroyInstance</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
<span class="w">        </span><span class="c1">// [...] Methods created in previous chapters.</span>

<span class="hll"><span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="n">GetViewConfigurationViews</span><span class="p">()</span>
</span><span class="hll"><span class="w">        </span><span class="p">{</span>
</span><span class="hll"><span class="w">        </span><span class="p">}</span>
</span><span class="hll"><span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="n">CreateSwapchains</span><span class="p">()</span>
</span><span class="hll"><span class="w">        </span><span class="p">{</span>
</span><span class="hll"><span class="w">        </span><span class="p">}</span>
</span><span class="hll"><span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="n">DestroySwapchains</span><span class="p">()</span>
</span><span class="hll"><span class="w">        </span><span class="p">{</span>
</span><span class="hll"><span class="w">        </span><span class="p">}</span>
</span>
<span class="k">private</span><span class="o">:</span>
<span class="w">        </span><span class="c1">// [...] Member created in previous chapters.</span>

<span class="hll"><span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">XrViewConfigurationType</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m_applicationViewConfigurations</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">XR_VIEW_CONFIGURATION_TYPE_PRIMARY_STEREO</span><span class="p">,</span><span class="w"> </span><span class="n">XR_VIEW_CONFIGURATION_TYPE_PRIMARY_MONO</span><span class="p">};</span>
</span><span class="hll"><span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">XrViewConfigurationType</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m_viewConfigurations</span><span class="p">;</span>
</span><span class="hll"><span class="w">        </span><span class="n">XrViewConfigurationType</span><span class="w"> </span><span class="n">m_viewConfiguration</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">XR_VIEW_CONFIGURATION_TYPE_MAX_ENUM</span><span class="p">;</span>
</span><span class="hll"><span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">XrViewConfigurationView</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m_viewConfigurationViews</span><span class="p">;</span>
</span><span class="hll">
</span><span class="hll"><span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">SwapchainInfo</span><span class="w"> </span><span class="p">{</span>
</span><span class="hll"><span class="w">                </span><span class="n">XrSwapchain</span><span class="w"> </span><span class="n">swapchain</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">XR_NULL_HANDLE</span><span class="p">;</span>
</span><span class="hll"><span class="w">                </span><span class="kt">int64_t</span><span class="w"> </span><span class="n">swapchainFormat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
</span><span class="hll"><span class="w">                </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">void</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="n">imageViews</span><span class="p">;</span>
</span><span class="hll"><span class="w">        </span><span class="p">};</span>
</span><span class="hll"><span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SwapchainInfo</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m_colorSwapchainInfos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
</span><span class="hll"><span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SwapchainInfo</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m_depthSwapchainInfos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
</span><span class="p">};</span>
</pre></div>
</div>
<p>We will explore the added methods in the sub-chapters below.</p>
<section id="view-configurations">
<h3>3.1.1 View Configurations<a class="headerlink" href="#view-configurations" title="Link to this heading">¶</a></h3>
<p>The first thing we need to do is get all the view configuration types available to our XR system. A view configuration type is a ‘semantically meaningful set of one or more views for which an application can render images’. (<a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/html/xrspec.html#view_configurations">8. View Configurations</a>.) Theres’s both mono and stereo types along others provided by hardware/software vendors.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="nc">XrViewConfigurationType</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">XR_VIEW_CONFIGURATION_TYPE_PRIMARY_MONO</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">    </span><span class="n">XR_VIEW_CONFIGURATION_TYPE_PRIMARY_STEREO</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>
<span class="w">    </span><span class="n">XR_VIEW_CONFIGURATION_TYPE_PRIMARY_QUAD_VARJO</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1000037000</span><span class="p">,</span>
<span class="w">    </span><span class="n">XR_VIEW_CONFIGURATION_TYPE_SECONDARY_MONO_FIRST_PERSON_OBSERVER_MSFT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1000054000</span><span class="p">,</span>
<span class="w">    </span><span class="n">XR_VIEW_CONFIGURATION_TYPE_MAX_ENUM</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x7FFFFFFF</span>
<span class="p">}</span><span class="w"> </span><span class="n">XrViewConfigurationType</span><span class="p">;</span>
</pre></div>
</div>
<p>We call <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/xrEnumerateViewConfigurations.html">xrEnumerateViewConfigurations</a> twice, first to get the count of the types for our XR system, and second to fill in the data to the <code class="docutils literal notranslate"><span class="pre">std::vector&lt;XrViewConfigurationType&gt;</span></code>. Reference: <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrViewConfigurationType.html">XrViewConfigurationType</a>. Next, we check against a list of view configuration types that are supported by the application and select one.</p>
<p>Now, we need get all of the views available to our view configuration. It is worth just parsing the name of this type: <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrViewConfigurationView.html">XrViewConfigurationView</a>. We can break the typename up as follows “XrViewConfiguration” - “View”, where it relates to one view in the view configuration, which may contain multiple views. We call <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/xrEnumerateViewConfigurationViews.html">xrEnumerateViewConfigurationViews</a> twice, first to get the count of the views in the view configuration, and second to fill in the data to the <code class="docutils literal notranslate"><span class="pre">std::vector&lt;XrViewConfigurationView&gt;</span></code>.</p>
<p>Add the following code to the <code class="docutils literal notranslate"><span class="pre">GetViewConfigurationViews()</span></code> method:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Gets the View Configuration Types. The first call gets the count of the array that will be returned. The next call fills out the array.</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">viewConfigurationCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">OPENXR_CHECK</span><span class="p">(</span><span class="n">xrEnumerateViewConfigurations</span><span class="p">(</span><span class="n">m_xrInstance</span><span class="p">,</span><span class="w"> </span><span class="n">m_systemID</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">viewConfigurationCount</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Failed to enumerate View Configurations.&quot;</span><span class="p">);</span>
<span class="n">m_viewConfigurations</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">viewConfigurationCount</span><span class="p">);</span>
<span class="n">OPENXR_CHECK</span><span class="p">(</span><span class="n">xrEnumerateViewConfigurations</span><span class="p">(</span><span class="n">m_xrInstance</span><span class="p">,</span><span class="w"> </span><span class="n">m_systemID</span><span class="p">,</span><span class="w"> </span><span class="n">viewConfigurationCount</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">viewConfigurationCount</span><span class="p">,</span><span class="w"> </span><span class="n">m_viewConfigurations</span><span class="p">.</span><span class="n">data</span><span class="p">()),</span><span class="w"> </span><span class="s">&quot;Failed to enumerate View Configurations.&quot;</span><span class="p">);</span>

<span class="c1">// Pick the first application supported View Configuration Type con supported by the hardware.</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">XrViewConfigurationType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">viewConfiguration</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">m_applicationViewConfigurations</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">m_viewConfigurations</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">m_viewConfigurations</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="n">viewConfiguration</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">m_viewConfigurations</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">m_viewConfiguration</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">viewConfiguration</span><span class="p">;</span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_viewConfiguration</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">XR_VIEW_CONFIGURATION_TYPE_MAX_ENUM</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Failed to find a view configuration type. Defaulting to XR_VIEW_CONFIGURATION_TYPE_PRIMARY_STEREO.&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="n">m_viewConfiguration</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">XR_VIEW_CONFIGURATION_TYPE_PRIMARY_STEREO</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Gets the View Configuration Views. The first call gets the count of the array that will be returned. The next call fills out the array.</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">viewConfigurationViewCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">OPENXR_CHECK</span><span class="p">(</span><span class="n">xrEnumerateViewConfigurationViews</span><span class="p">(</span><span class="n">m_xrInstance</span><span class="p">,</span><span class="w"> </span><span class="n">m_systemID</span><span class="p">,</span><span class="w"> </span><span class="n">m_viewConfiguration</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">viewConfigurationViewCount</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Failed to enumerate ViewConfiguration Views.&quot;</span><span class="p">);</span>
<span class="n">m_viewConfigurationViews</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">viewConfigurationViewCount</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">XR_TYPE_VIEW_CONFIGURATION_VIEW</span><span class="p">});</span>
<span class="n">OPENXR_CHECK</span><span class="p">(</span><span class="n">xrEnumerateViewConfigurationViews</span><span class="p">(</span><span class="n">m_xrInstance</span><span class="p">,</span><span class="w"> </span><span class="n">m_systemID</span><span class="p">,</span><span class="w"> </span><span class="n">m_viewConfiguration</span><span class="p">,</span><span class="w"> </span><span class="n">viewConfigurationViewCount</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">viewConfigurationViewCount</span><span class="p">,</span><span class="w"> </span><span class="n">m_viewConfigurationViews</span><span class="p">.</span><span class="n">data</span><span class="p">()),</span><span class="w"> </span><span class="s">&quot;Failed to enumerate ViewConfiguration Views.&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>From the code in <a class="reference internal" href="2-setup.html#xrpollevent"><span class="std std-ref">Chapter 2.3.1</span></a>, we modify our assignment of <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrSessionBeginInfo.html">XrSessionBeginInfo</a> <code class="docutils literal notranslate"><span class="pre">::primaryViewConfigurationType</span></code> in the <code class="docutils literal notranslate"><span class="pre">PollEvents()</span></code> to use the class member <code class="docutils literal notranslate"><span class="pre">m_viewConfiguration</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sessionStateChanged</span><span class="o">-&gt;</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">XR_SESSION_STATE_READY</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// SessionState is ready. Begin the XrSession using the XrViewConfigurationType.</span>
<span class="w">    </span><span class="n">XrSessionBeginInfo</span><span class="w"> </span><span class="n">sessionBeginInfo</span><span class="p">{</span><span class="n">XR_TYPE_SESSION_BEGIN_INFO</span><span class="p">};</span>
<span class="hll"><span class="w">    </span><span class="n">sessionBeginInfo</span><span class="p">.</span><span class="n">primaryViewConfigurationType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_viewConfiguration</span><span class="p">;</span>
</span><span class="w">    </span><span class="n">OPENXR_CHECK</span><span class="p">(</span><span class="n">xrBeginSession</span><span class="p">(</span><span class="n">m_session</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sessionBeginInfo</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Failed to begin Session.&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">m_sessionRunning</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="enumerate-the-swapchain-formats">
<h3>3.1.2 Enumerate the Swapchain Formats<a class="headerlink" href="#enumerate-the-swapchain-formats" title="Link to this heading">¶</a></h3>
<p>For each runtime, the OpenXR compositor has certain preferred image formats that should be used by the swapchain. When calling <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/xrEnumerateSwapchainFormats.html">xrEnumerateSwapchainFormats</a>, the <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrSession.html">XrSession</a> and the Graphics API will return an array of API-specific formats ordered by preference. <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/xrEnumerateSwapchainFormats.html">xrEnumerateSwapchainFormats</a> takes a pointer to the first element in an array of <code class="docutils literal notranslate"><span class="pre">int64_t</span></code> values. The use of <code class="docutils literal notranslate"><span class="pre">int64_t</span></code> is a simple type cast from a <code class="docutils literal notranslate"><span class="pre">DXGI_FORMAT</span></code>, <code class="docutils literal notranslate"><span class="pre">GLenum</span></code> or a <code class="docutils literal notranslate"><span class="pre">VkFormat</span></code>. The runtime “should support <code class="docutils literal notranslate"><span class="pre">R8G8B8A8</span></code> and <code class="docutils literal notranslate"><span class="pre">R8G8B8A8</span> <span class="pre">sRGB</span></code> formats if possible” (<a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/html/xrspec.html#swapchain-image-management">OpenXR Specification 10.1. Swapchain Image Management</a>).</p>
<p>Both Linear and sRGB color spaces are supported and one may have preference over the other. In cases where you are compositing multiple layers, you may wish to use linear color spaces only, as OpenXR’s compositor will perform all blend operations in a linear color space for correctness. For certain runtimes, systems and/or applications, sRGB maybe preferred especially if there’s just a single opaque layer to composite.</p>
<p>If you wish to use an sRGB color format, you <em>must</em> use an API-specific sRGB color format such as <code class="docutils literal notranslate"><span class="pre">DXGI_FORMAT_R8G8B8A8_UNORM_SRGB</span></code>, <code class="docutils literal notranslate"><span class="pre">GL_SRGB8_ALPHA8</span></code> or <code class="docutils literal notranslate"><span class="pre">VK_FORMAT_R8G8B8A8_SRGB</span></code> for the OpenXR runtime to automatically do sRGB-to-linear color space conversions when reading the image.</p>
<p>We also check that the runtime has a supported depth format so that we can create a depth swapchain. You can check this with <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/xrEnumerateSwapchainFormats.html">xrEnumerateSwapchainFormats</a>. Unfortunately, there are no guarantees with in the OpenXR 1.0 core specification or the <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XR_KHR_composition_layer_depth.html">XR_KHR_composition_layer_depth</a> extension revision 6 that states runtimes must support depth format for swapchains. Most XR systems and/or run support depth swapchain formats. This will be useful for <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XR_KHR_composition_layer_depth.html">XR_KHR_composition_layer_depth</a> and AR applications. See <a class="reference internal" href="5-extensions.html#composition-layer-depth"><span class="std std-ref">Chapter 5.2</span></a>.</p>
<p>If no swapchain depth format is found, applications should use a depth buffer/texture to render graphics. This depth buffer/texture can not be used with <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XR_KHR_composition_layer_depth.html">XR_KHR_composition_layer_depth</a>.</p>
<p>Copy the code below into the <code class="docutils literal notranslate"><span class="pre">CreateSwapchains()</span></code> method:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Get the supported swapchain formats as an array of int64_t and ordered by runtime preference.</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">formatCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">OPENXR_CHECK</span><span class="p">(</span><span class="n">xrEnumerateSwapchainFormats</span><span class="p">(</span><span class="n">m_session</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">formatCount</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Failed to enumerate Swapchain Formats&quot;</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">formats</span><span class="p">(</span><span class="n">formatCount</span><span class="p">);</span>
<span class="n">OPENXR_CHECK</span><span class="p">(</span><span class="n">xrEnumerateSwapchainFormats</span><span class="p">(</span><span class="n">m_session</span><span class="p">,</span><span class="w"> </span><span class="n">formatCount</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">formatCount</span><span class="p">,</span><span class="w"> </span><span class="n">formats</span><span class="p">.</span><span class="n">data</span><span class="p">()),</span><span class="w"> </span><span class="s">&quot;Failed to enumerate Swapchain Formats&quot;</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">SelectDepthSwapchainFormat</span><span class="p">(</span><span class="n">formats</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Failed to find depth format for Swapchain.&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="n">DEBUG_BREAK</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="create-the-swapchains">
<h3>3.1.3 Create the Swapchains<a class="headerlink" href="#create-the-swapchains" title="Link to this heading">¶</a></h3>
<p>We will create an <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrSwapchain.html">XrSwapchain</a> for each view in the system. First, we will resize our color and depth <code class="docutils literal notranslate"><span class="pre">std::vector&lt;SwapchainInfo&gt;</span></code> s to match the number of views in the system. Next, we set up a loop to iterate through and create the swapchains and all the image views.
Append the following two code blocks to the <code class="docutils literal notranslate"><span class="pre">CreateSwapchains()</span></code> method:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//Resize the SwapchainInfo to match the number of view in the View Configuration.</span>
<span class="n">m_colorSwapchainInfos</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">m_viewConfigurationViews</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
<span class="n">m_depthSwapchainInfos</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">m_viewConfigurationViews</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">m_viewConfigurationViews</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Inside the for loop of the <code class="docutils literal notranslate"><span class="pre">CreateSwapchains()</span></code> method, add the following code:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">SwapchainInfo</span><span class="w"> </span><span class="o">&amp;</span><span class="n">colorSwapchainInfo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_colorSwapchainInfos</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="n">SwapchainInfo</span><span class="w"> </span><span class="o">&amp;</span><span class="n">depthSwapchainInfo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_depthSwapchainInfos</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

<span class="c1">// Fill out an XrSwapchainCreateInfo structure and create an XrSwapchain.</span>
<span class="c1">// Color.</span>
<span class="n">XrSwapchainCreateInfo</span><span class="w"> </span><span class="n">swapchainCI</span><span class="p">{</span><span class="n">XR_TYPE_SWAPCHAIN_CREATE_INFO</span><span class="p">};</span>
<span class="n">swapchainCI</span><span class="p">.</span><span class="n">createFlags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">swapchainCI</span><span class="p">.</span><span class="n">usageFlags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">XR_SWAPCHAIN_USAGE_SAMPLED_BIT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">XR_SWAPCHAIN_USAGE_COLOR_ATTACHMENT_BIT</span><span class="p">;</span>
<span class="n">swapchainCI</span><span class="p">.</span><span class="n">format</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">SelectColorSwapchainFormat</span><span class="p">(</span><span class="n">formats</span><span class="p">);</span><span class="w">                </span><span class="c1">// Use GraphicsAPI to select the first compatible format.</span>
<span class="n">swapchainCI</span><span class="p">.</span><span class="n">sampleCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_viewConfigurationViews</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">recommendedSwapchainSampleCount</span><span class="p">;</span><span class="w">  </span><span class="c1">// Use the recommended values from the XrViewConfigurationView.</span>
<span class="n">swapchainCI</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_viewConfigurationViews</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">recommendedImageRectWidth</span><span class="p">;</span>
<span class="n">swapchainCI</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_viewConfigurationViews</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">recommendedImageRectHeight</span><span class="p">;</span>
<span class="n">swapchainCI</span><span class="p">.</span><span class="n">faceCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">swapchainCI</span><span class="p">.</span><span class="n">arraySize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">swapchainCI</span><span class="p">.</span><span class="n">mipCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">OPENXR_CHECK</span><span class="p">(</span><span class="n">xrCreateSwapchain</span><span class="p">(</span><span class="n">m_session</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">swapchainCI</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">colorSwapchainInfo</span><span class="p">.</span><span class="n">swapchain</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Failed to create Color Swapchain&quot;</span><span class="p">);</span>
<span class="n">colorSwapchainInfo</span><span class="p">.</span><span class="n">swapchainFormat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">swapchainCI</span><span class="p">.</span><span class="n">format</span><span class="p">;</span><span class="w">  </span><span class="c1">// Save the swapchain format for later use.</span>

<span class="c1">// Depth.</span>
<span class="n">swapchainCI</span><span class="p">.</span><span class="n">createFlags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">swapchainCI</span><span class="p">.</span><span class="n">usageFlags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">XR_SWAPCHAIN_USAGE_SAMPLED_BIT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">XR_SWAPCHAIN_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT</span><span class="p">;</span>
<span class="n">swapchainCI</span><span class="p">.</span><span class="n">format</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">SelectDepthSwapchainFormat</span><span class="p">(</span><span class="n">formats</span><span class="p">);</span><span class="w">                </span><span class="c1">// Use GraphicsAPI to select the first compatible format.</span>
<span class="n">swapchainCI</span><span class="p">.</span><span class="n">sampleCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_viewConfigurationViews</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">recommendedSwapchainSampleCount</span><span class="p">;</span><span class="w">  </span><span class="c1">// Use the recommended values from the XrViewConfigurationView.</span>
<span class="n">swapchainCI</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_viewConfigurationViews</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">recommendedImageRectWidth</span><span class="p">;</span>
<span class="n">swapchainCI</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_viewConfigurationViews</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">recommendedImageRectHeight</span><span class="p">;</span>
<span class="n">swapchainCI</span><span class="p">.</span><span class="n">faceCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">swapchainCI</span><span class="p">.</span><span class="n">arraySize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">swapchainCI</span><span class="p">.</span><span class="n">mipCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">OPENXR_CHECK</span><span class="p">(</span><span class="n">xrCreateSwapchain</span><span class="p">(</span><span class="n">m_session</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">swapchainCI</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">depthSwapchainInfo</span><span class="p">.</span><span class="n">swapchain</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Failed to create Depth Swapchain&quot;</span><span class="p">);</span>
<span class="n">depthSwapchainInfo</span><span class="p">.</span><span class="n">swapchainFormat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">swapchainCI</span><span class="p">.</span><span class="n">format</span><span class="p">;</span><span class="w">  </span><span class="c1">// Save the swapchain format for later use.</span>
</pre></div>
</div>
<p>Here, we’ve filled out the <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrSwapchainCreateInfo.html">XrSwapchainCreateInfo</a> structure. The <code class="docutils literal notranslate"><span class="pre">sampleCount</span></code>, <code class="docutils literal notranslate"><span class="pre">width</span></code> and <code class="docutils literal notranslate"><span class="pre">height</span></code> members were assigned from the related <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrViewConfigurationView.html">XrViewConfigurationView</a>. We set the <code class="docutils literal notranslate"><span class="pre">createFlags</span></code> to <code class="docutils literal notranslate"><span class="pre">0</span></code> as we require no constraints or additional functionality. We set the <code class="docutils literal notranslate"><span class="pre">usageFlags</span></code> to <code class="docutils literal notranslate"><span class="pre">XR_SWAPCHAIN_USAGE_SAMPLED_BIT</span> <span class="pre">|</span> <span class="pre">XR_SWAPCHAIN_USAGE_COLOR_ATTACHMENT_BIT</span></code> requesting that the images are suitable to be read in a shader and to be used as a render target/color attachment. For the depth swapchain, we set the <code class="docutils literal notranslate"><span class="pre">usageFlags</span></code> to <code class="docutils literal notranslate"><span class="pre">XR_SWAPCHAIN_USAGE_SAMPLED_BIT</span> <span class="pre">|</span> <span class="pre">XR_SWAPCHAIN_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT</span></code> as these images will be used as a depth stencil attachments.</p>
<p class="rubric">Vulkan</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>XrSwapchainUsageFlagBits</p></td>
<td><p>Corresponding Vulkan flag bit</p></td>
</tr>
<tr class="row-even"><td><p>XR_SWAPCHAIN_USAGE_COLOR_ATTACHMENT_BIT</p></td>
<td><p>VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</p></td>
</tr>
<tr class="row-odd"><td><p>XR_SWAPCHAIN_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT</p></td>
<td><p>VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT</p></td>
</tr>
<tr class="row-even"><td><p>XR_SWAPCHAIN_USAGE_UNORDERED_ACCESS_BIT</p></td>
<td><p>VK_IMAGE_USAGE_STORAGE_BIT</p></td>
</tr>
<tr class="row-odd"><td><p>XR_SWAPCHAIN_USAGE_TRANSFER_SRC_BIT</p></td>
<td><p>VK_IMAGE_USAGE_TRANSFER_SRC_BIT</p></td>
</tr>
<tr class="row-even"><td><p>XR_SWAPCHAIN_USAGE_TRANSFER_DST_BIT</p></td>
<td><p>VK_IMAGE_USAGE_TRANSFER_DST_BIT</p></td>
</tr>
<tr class="row-odd"><td><p>XR_SWAPCHAIN_USAGE_SAMPLED_BIT</p></td>
<td><p>VK_IMAGE_USAGE_SAMPLED_BIT</p></td>
</tr>
<tr class="row-even"><td><p>XR_SWAPCHAIN_USAGE_MUTABLE_FORMAT_BIT</p></td>
<td><p>VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT</p></td>
</tr>
<tr class="row-odd"><td><p>XR_SWAPCHAIN_USAGE_INPUT_ATTACHMENT_BIT_KHR</p></td>
<td><p>VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT</p></td>
</tr>
</tbody>
</table>
<p>Then, we set the values for <code class="docutils literal notranslate"><span class="pre">faceCount</span></code>, <code class="docutils literal notranslate"><span class="pre">arraySize</span></code> and <code class="docutils literal notranslate"><span class="pre">mipCount</span></code>. <code class="docutils literal notranslate"><span class="pre">faceCount</span></code> describes the number of faces in the image and is used for creating cubemap textures. <code class="docutils literal notranslate"><span class="pre">arraySize</span></code> describes the number of layers in an image. Here, we used <code class="docutils literal notranslate"><span class="pre">1</span></code>, as we have separate swapchains per view/eye. If your graphics API supports multiview rendering (See <a class="reference internal" href="6-next-steps.html#multiview-rendering"><span class="std std-ref">Chapter 6.1</span></a>.), you could pass <code class="docutils literal notranslate"><span class="pre">2</span></code> and have a 2D image array. <code class="docutils literal notranslate"><span class="pre">mipCount</span></code> describes the number of texture detail levels; this is useful when using the swapchain image as a sampled image in a shader. Finally, we set the format. Here, we asked our <code class="docutils literal notranslate"><span class="pre">GraphicsAPI_...</span></code> class to pick a suitable format for the swapchain from the enumerated formats we acquired earlier.</p>
<p>Here is the code for <code class="docutils literal notranslate"><span class="pre">GraphicsAPI::SelectSwapchainFormat()</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int64_t</span><span class="w"> </span><span class="nf">GraphicsAPI::SelectColorSwapchainFormat</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">formats</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">supportSwapchainFormats</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetSupportedColorSwapchainFormats</span><span class="p">();</span>

<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;::</span><span class="n">const_iterator</span><span class="w"> </span><span class="o">&amp;</span><span class="n">swapchainFormatIt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">find_first_of</span><span class="p">(</span><span class="n">formats</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">formats</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
<span class="w">                                                                                       </span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">supportSwapchainFormats</span><span class="p">),</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">supportSwapchainFormats</span><span class="p">));</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">swapchainFormatIt</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">formats</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;ERROR: Unable to find supported Color Swapchain Format&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">        </span><span class="n">DEBUG_BREAK</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="n">swapchainFormatIt</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int64_t</span><span class="w"> </span><span class="nf">GraphicsAPI::SelectDepthSwapchainFormat</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">formats</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">supportSwapchainFormats</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetSupportedDepthSwapchainFormats</span><span class="p">();</span>

<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;::</span><span class="n">const_iterator</span><span class="w"> </span><span class="o">&amp;</span><span class="n">swapchainFormatIt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">find_first_of</span><span class="p">(</span><span class="n">formats</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">formats</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
<span class="w">                                                                                       </span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">supportSwapchainFormats</span><span class="p">),</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">supportSwapchainFormats</span><span class="p">));</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">swapchainFormatIt</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">formats</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;ERROR: Unable to find supported Depth Swapchain Format&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">        </span><span class="n">DEBUG_BREAK</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="n">swapchainFormatIt</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><em>The above code is an excerpt from Common/GraphicsAPI.cpp</em></p>
<p>The functions each call a pure virtual method called <code class="docutils literal notranslate"><span class="pre">GraphicsAPI::SelectColorSwapchainFormat()</span></code> and <code class="docutils literal notranslate"><span class="pre">GraphicsAPI::SelectDepthSwapchainFormat()</span></code> respectively, which each class implements. It returns an array of API-specific formats that the GraphicsAPI library supports.</p>
<p class="rubric">Vulkan</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">GraphicsAPI_Vulkan</span><span class="o">::</span><span class="n">GetSupportedColorSwapchainFormats</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">VK_FORMAT_B8G8R8A8_SRGB</span><span class="p">,</span>
<span class="w">        </span><span class="n">VK_FORMAT_R8G8B8A8_SRGB</span><span class="p">,</span>
<span class="w">        </span><span class="n">VK_FORMAT_B8G8R8A8_UNORM</span><span class="p">,</span>
<span class="w">        </span><span class="n">VK_FORMAT_R8G8B8A8_UNORM</span><span class="p">};</span>
<span class="p">}</span>
<span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">GraphicsAPI_Vulkan</span><span class="o">::</span><span class="n">GetSupportedDepthSwapchainFormats</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">VK_FORMAT_D32_SFLOAT</span><span class="p">,</span>
<span class="w">        </span><span class="n">VK_FORMAT_D16_UNORM</span><span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p><em>The above code is an excerpt from Common/GraphicsAPI_Vulkan.cpp</em></p>
<p>Lastly, we called <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/xrCreateSwapchain.html">xrCreateSwapchain</a> to create our <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrSwapchain.html">XrSwapchain</a>, which, if successful, returned <code class="docutils literal notranslate"><span class="pre">XR_SUCCESS</span></code> and the <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrSwapchain.html">XrSwapchain</a> was non-null. We copied our swapchain format to our <code class="docutils literal notranslate"><span class="pre">SwapchainInfo::swapchainFormat</span></code> for later usage.</p>
<p>The same process is repeated for the depth swapchain.</p>
</section>
<section id="enumerate-swapchain-images">
<h3>3.1.4 Enumerate Swapchain Images<a class="headerlink" href="#enumerate-swapchain-images" title="Link to this heading">¶</a></h3>
<p>Now that we have created the swapchain, we need to get access to its images. We first call <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/xrEnumerateSwapchainImages.html">xrEnumerateSwapchainImages</a> to get the count of the images in the swapchain. Next, we set up an array of structures to store the images from the <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrSwapchain.html">XrSwapchain</a>. In this tutorial, this array of structures, which stores the swapchains images, is stored in the <code class="docutils literal notranslate"><span class="pre">GraphicsAPI_...</span></code> class. We use the <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrSwapchain.html">XrSwapchain</a> handle as the key to an <code class="docutils literal notranslate"><span class="pre">std::unordered_map</span></code> to get the type and the images relating to the swapchain. They are stored inside the <code class="docutils literal notranslate"><span class="pre">GraphicsAPI_...</span></code> class, because OpenXR will return to the application an array of structures that contain the API-specific handles to the swapchain images. <code class="docutils literal notranslate"><span class="pre">GraphicsAPI::AllocateSwapchainImageData()</span></code> is a virtual method implemented by each graphics API, which stores the type and resizes an API-specific <code class="docutils literal notranslate"><span class="pre">std::vector&lt;XrSwapchainImage...KHR&gt;</span></code> and returns a pointer to the first element in that array casting it to a <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrSwapchainImageBaseHeader.html">XrSwapchainImageBaseHeader</a> pointer.
The same process is repeated for the depth swapchain.</p>
<p>Copy and append the following code into the for loop of the <code class="docutils literal notranslate"><span class="pre">CreateSwapchains()</span></code> method.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Get the number of images in the color/depth swapchain and allocate Swapchain image data via GraphicsAPI to store the returned array.</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">colorSwapchainImageCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">OPENXR_CHECK</span><span class="p">(</span><span class="n">xrEnumerateSwapchainImages</span><span class="p">(</span><span class="n">colorSwapchainInfo</span><span class="p">.</span><span class="n">swapchain</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">colorSwapchainImageCount</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Failed to enumerate Color Swapchain Images.&quot;</span><span class="p">);</span>
<span class="n">XrSwapchainImageBaseHeader</span><span class="w"> </span><span class="o">*</span><span class="n">colorSwapchainImages</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">AllocateSwapchainImageData</span><span class="p">(</span><span class="n">colorSwapchainInfo</span><span class="p">.</span><span class="n">swapchain</span><span class="p">,</span><span class="w"> </span><span class="n">GraphicsAPI</span><span class="o">::</span><span class="n">SwapchainType</span><span class="o">::</span><span class="n">COLOR</span><span class="p">,</span><span class="w"> </span><span class="n">colorSwapchainImageCount</span><span class="p">);</span>
<span class="n">OPENXR_CHECK</span><span class="p">(</span><span class="n">xrEnumerateSwapchainImages</span><span class="p">(</span><span class="n">colorSwapchainInfo</span><span class="p">.</span><span class="n">swapchain</span><span class="p">,</span><span class="w"> </span><span class="n">colorSwapchainImageCount</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">colorSwapchainImageCount</span><span class="p">,</span><span class="w"> </span><span class="n">colorSwapchainImages</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Failed to enumerate Color Swapchain Images.&quot;</span><span class="p">);</span>

<span class="kt">uint32_t</span><span class="w"> </span><span class="n">depthSwapchainImageCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">OPENXR_CHECK</span><span class="p">(</span><span class="n">xrEnumerateSwapchainImages</span><span class="p">(</span><span class="n">depthSwapchainInfo</span><span class="p">.</span><span class="n">swapchain</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">depthSwapchainImageCount</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Failed to enumerate Depth Swapchain Images.&quot;</span><span class="p">);</span>
<span class="n">XrSwapchainImageBaseHeader</span><span class="w"> </span><span class="o">*</span><span class="n">depthSwapchainImages</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">AllocateSwapchainImageData</span><span class="p">(</span><span class="n">depthSwapchainInfo</span><span class="p">.</span><span class="n">swapchain</span><span class="p">,</span><span class="w"> </span><span class="n">GraphicsAPI</span><span class="o">::</span><span class="n">SwapchainType</span><span class="o">::</span><span class="n">DEPTH</span><span class="p">,</span><span class="w"> </span><span class="n">depthSwapchainImageCount</span><span class="p">);</span>
<span class="n">OPENXR_CHECK</span><span class="p">(</span><span class="n">xrEnumerateSwapchainImages</span><span class="p">(</span><span class="n">depthSwapchainInfo</span><span class="p">.</span><span class="n">swapchain</span><span class="p">,</span><span class="w"> </span><span class="n">depthSwapchainImageCount</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">depthSwapchainImageCount</span><span class="p">,</span><span class="w"> </span><span class="n">depthSwapchainImages</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Failed to enumerate Depth Swapchain Images.&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Below is an excerpt of the <code class="docutils literal notranslate"><span class="pre">GraphicsAPI::AllocateSwapchainImageData()</span></code> method and the <code class="docutils literal notranslate"><span class="pre">XrSwapchainImage...KHR</span></code> structure relating to your chosen graphics API.</p>
<p class="rubric">Vulkan</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">XrSwapchainImageBaseHeader</span><span class="w"> </span><span class="o">*</span><span class="nf">GraphicsAPI_Vulkan::AllocateSwapchainImageData</span><span class="p">(</span><span class="n">XrSwapchain</span><span class="w"> </span><span class="n">swapchain</span><span class="p">,</span><span class="w"> </span><span class="n">SwapchainType</span><span class="w"> </span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">count</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">swapchainImagesMap</span><span class="p">[</span><span class="n">swapchain</span><span class="p">].</span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">type</span><span class="p">;</span>
<span class="w">    </span><span class="n">swapchainImagesMap</span><span class="p">[</span><span class="n">swapchain</span><span class="p">].</span><span class="n">second</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">XR_TYPE_SWAPCHAIN_IMAGE_VULKAN_KHR</span><span class="p">});</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">XrSwapchainImageBaseHeader</span><span class="w"> </span><span class="o">*&gt;</span><span class="p">(</span><span class="n">swapchainImagesMap</span><span class="p">[</span><span class="n">swapchain</span><span class="p">].</span><span class="n">second</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
<p><em>The above code is an excerpt from Common/GraphicsAPI_Vulkan.cpp</em></p>
<p><code class="docutils literal notranslate"><span class="pre">swapchainImagesMap</span></code> is of type <code class="docutils literal notranslate"><span class="pre">std::unordered_map&lt;XrSwapchain,</span> <span class="pre">std::pair&lt;SwapchainType,</span> <span class="pre">std::vector&lt;XrSwapchainImageVulkanKHR&gt;&gt;</span></code>. Reference: <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrSwapchainImageVulkanKHR.html">XrSwapchainImageVulkanKHR</a>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">XrSwapchainImageVulkanKHR</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">XrStructureType</span><span class="w">       </span><span class="n">type</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">XR_MAY_ALIAS</span><span class="w">    </span><span class="n">next</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkImage</span><span class="w">               </span><span class="n">image</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">XrSwapchainImageVulkanKHR</span><span class="p">;</span>
</pre></div>
</div>
<p><em>The above code is an excerpt from openxr/openxr_platform.h</em></p>
<p>The structure contains a <code class="docutils literal notranslate"><span class="pre">VkImage</span></code> member that is the handle to one of the images in the swapchain.</p>
</section>
<section id="create-the-swapchain-image-views">
<h3>3.1.5 Create the Swapchain Image Views<a class="headerlink" href="#create-the-swapchain-image-views" title="Link to this heading">¶</a></h3>
<p>Now, we create the image views: one per image in the color and depth <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrSwapchain.html">XrSwapchain</a> s. In this tutorial, we have a <code class="docutils literal notranslate"><span class="pre">GraphicsAPI::ImageViewCreateInfo</span></code> structure and virtual method <code class="docutils literal notranslate"><span class="pre">GraphicsAPI::CreateImageView()</span></code> that creates the API-specific objects. We create swapchain image views of both the color and depth swapchains.</p>
<p>Append the following code into the for loop of the <code class="docutils literal notranslate"><span class="pre">CreateSwapchains()</span></code> method.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Per image in the swapchains, fill out a GraphicsAPI::ImageViewCreateInfo structure and create a color/depth image view.</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">colorSwapchainImageCount</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">GraphicsAPI</span><span class="o">::</span><span class="n">ImageViewCreateInfo</span><span class="w"> </span><span class="n">imageViewCI</span><span class="p">;</span>
<span class="w">    </span><span class="n">imageViewCI</span><span class="p">.</span><span class="n">image</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">GetSwapchainImage</span><span class="p">(</span><span class="n">colorSwapchainInfo</span><span class="p">.</span><span class="n">swapchain</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">);</span>
<span class="w">    </span><span class="n">imageViewCI</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GraphicsAPI</span><span class="o">::</span><span class="n">ImageViewCreateInfo</span><span class="o">::</span><span class="n">Type</span><span class="o">::</span><span class="n">RTV</span><span class="p">;</span>
<span class="w">    </span><span class="n">imageViewCI</span><span class="p">.</span><span class="n">view</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GraphicsAPI</span><span class="o">::</span><span class="n">ImageViewCreateInfo</span><span class="o">::</span><span class="n">View</span><span class="o">::</span><span class="n">TYPE_2D</span><span class="p">;</span>
<span class="w">    </span><span class="n">imageViewCI</span><span class="p">.</span><span class="n">format</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">colorSwapchainInfo</span><span class="p">.</span><span class="n">swapchainFormat</span><span class="p">;</span>
<span class="w">    </span><span class="n">imageViewCI</span><span class="p">.</span><span class="n">aspect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GraphicsAPI</span><span class="o">::</span><span class="n">ImageViewCreateInfo</span><span class="o">::</span><span class="n">Aspect</span><span class="o">::</span><span class="n">COLOR_BIT</span><span class="p">;</span>
<span class="w">    </span><span class="n">imageViewCI</span><span class="p">.</span><span class="n">baseMipLevel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">imageViewCI</span><span class="p">.</span><span class="n">levelCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">imageViewCI</span><span class="p">.</span><span class="n">baseArrayLayer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">imageViewCI</span><span class="p">.</span><span class="n">layerCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">colorSwapchainInfo</span><span class="p">.</span><span class="n">imageViews</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">CreateImageView</span><span class="p">(</span><span class="n">imageViewCI</span><span class="p">));</span>
<span class="p">}</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">depthSwapchainImageCount</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">GraphicsAPI</span><span class="o">::</span><span class="n">ImageViewCreateInfo</span><span class="w"> </span><span class="n">imageViewCI</span><span class="p">;</span>
<span class="w">    </span><span class="n">imageViewCI</span><span class="p">.</span><span class="n">image</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">GetSwapchainImage</span><span class="p">(</span><span class="n">depthSwapchainInfo</span><span class="p">.</span><span class="n">swapchain</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">);</span>
<span class="w">    </span><span class="n">imageViewCI</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GraphicsAPI</span><span class="o">::</span><span class="n">ImageViewCreateInfo</span><span class="o">::</span><span class="n">Type</span><span class="o">::</span><span class="n">DSV</span><span class="p">;</span>
<span class="w">    </span><span class="n">imageViewCI</span><span class="p">.</span><span class="n">view</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GraphicsAPI</span><span class="o">::</span><span class="n">ImageViewCreateInfo</span><span class="o">::</span><span class="n">View</span><span class="o">::</span><span class="n">TYPE_2D</span><span class="p">;</span>
<span class="w">    </span><span class="n">imageViewCI</span><span class="p">.</span><span class="n">format</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">depthSwapchainInfo</span><span class="p">.</span><span class="n">swapchainFormat</span><span class="p">;</span>
<span class="w">    </span><span class="n">imageViewCI</span><span class="p">.</span><span class="n">aspect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GraphicsAPI</span><span class="o">::</span><span class="n">ImageViewCreateInfo</span><span class="o">::</span><span class="n">Aspect</span><span class="o">::</span><span class="n">DEPTH_BIT</span><span class="p">;</span>
<span class="w">    </span><span class="n">imageViewCI</span><span class="p">.</span><span class="n">baseMipLevel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">imageViewCI</span><span class="p">.</span><span class="n">levelCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">imageViewCI</span><span class="p">.</span><span class="n">baseArrayLayer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">imageViewCI</span><span class="p">.</span><span class="n">layerCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">depthSwapchainInfo</span><span class="p">.</span><span class="n">imageViews</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">CreateImageView</span><span class="p">(</span><span class="n">imageViewCI</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Each graphics API overrides the virtual function <code class="docutils literal notranslate"><span class="pre">GraphicsAPI::GetSwapchainImage()</span></code>, which returns an API-specific handle to the image, which is cast to a <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span></code>.</p>
<p class="rubric">Vulkan</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="nf">GetSwapchainImage</span><span class="p">(</span><span class="n">XrSwapchain</span><span class="w"> </span><span class="n">swapchain</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">VkImage</span><span class="w"> </span><span class="n">image</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">swapchainImagesMap</span><span class="p">[</span><span class="n">swapchain</span><span class="p">].</span><span class="n">second</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">image</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkImageLayout</span><span class="w"> </span><span class="n">layout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">swapchainImagesMap</span><span class="p">[</span><span class="n">swapchain</span><span class="p">].</span><span class="n">first</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">SwapchainType</span><span class="o">::</span><span class="n">COLOR</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL</span><span class="p">;</span>
<span class="w">    </span><span class="n">imageStates</span><span class="p">[</span><span class="n">image</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">layout</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">image</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For Vulkan, the <code class="docutils literal notranslate"><span class="pre">VkImage</span></code> returned has all of its subresource states in <code class="docutils literal notranslate"><span class="pre">VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</span></code> for color and <code class="docutils literal notranslate"><span class="pre">VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL</span></code> for depth. This is a requirement of the OpenXR 1.0 Vulkan extension. See: <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/html/xrspec.html#XR_KHR_vulkan_enable">12.20. XR_KHR_vulkan_enable</a>.</p>
<p><em>The above code is an excerpt from Common/GraphicsAPI_Vulkan.h</em></p>
<p>For the color and depth image views, we use the previously stored color/depth image format, that we used when creating their respective swapchains. We store our newly created color and depth image views for the swapchains in separate <code class="docutils literal notranslate"><span class="pre">SwapchainInfo::imageViews</span></code> instantiations.</p>
</section>
<section id="destroy-the-swapchain">
<h3>3.1.6 Destroy the Swapchain<a class="headerlink" href="#destroy-the-swapchain" title="Link to this heading">¶</a></h3>
<p>When the main render loop has finished and the application is shutting down, we need to destroy our created <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrSwapchain.html">XrSwapchain</a> s. This is done by calling <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/xrDestroySwapchain.html">xrDestroySwapchain</a> passing the <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrSwapchain.html">XrSwapchain</a> as a parameter. It will return <code class="docutils literal notranslate"><span class="pre">XR_SUCCESS</span></code> if successful. At the same time, we destroy all of the image views (both color and depth) by calling <code class="docutils literal notranslate"><span class="pre">GraphicsAPI::DestroyImageView()</span></code> and freeing all the allocated swapchain image data with <code class="docutils literal notranslate"><span class="pre">GraphicsAPI::FreeSwapchainImageData()</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Per view in the view configuration:</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">m_viewConfigurationViews</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">SwapchainInfo</span><span class="w"> </span><span class="o">&amp;</span><span class="n">colorSwapchainInfo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_colorSwapchainInfos</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">    </span><span class="n">SwapchainInfo</span><span class="w"> </span><span class="o">&amp;</span><span class="n">depthSwapchainInfo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_depthSwapchainInfos</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

<span class="w">    </span><span class="c1">// Destroy the color and depth image views from GraphicsAPI.</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*&amp;</span><span class="n">imageView</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">colorSwapchainInfo</span><span class="p">.</span><span class="n">imageViews</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">DestroyImageView</span><span class="p">(</span><span class="n">imageView</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*&amp;</span><span class="n">imageView</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">depthSwapchainInfo</span><span class="p">.</span><span class="n">imageViews</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">DestroyImageView</span><span class="p">(</span><span class="n">imageView</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Free the Swapchain Image Data.</span>
<span class="w">    </span><span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">FreeSwapchainImageData</span><span class="p">(</span><span class="n">colorSwapchainInfo</span><span class="p">.</span><span class="n">swapchain</span><span class="p">);</span>
<span class="w">    </span><span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">FreeSwapchainImageData</span><span class="p">(</span><span class="n">depthSwapchainInfo</span><span class="p">.</span><span class="n">swapchain</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Destroy the swapchains.</span>
<span class="w">    </span><span class="n">OPENXR_CHECK</span><span class="p">(</span><span class="n">xrDestroySwapchain</span><span class="p">(</span><span class="n">colorSwapchainInfo</span><span class="p">.</span><span class="n">swapchain</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Failed to destroy Color Swapchain&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">OPENXR_CHECK</span><span class="p">(</span><span class="n">xrDestroySwapchain</span><span class="p">(</span><span class="n">depthSwapchainInfo</span><span class="p">.</span><span class="n">swapchain</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Failed to destroy Depth Swapchain&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We now have swapchains and image views, ready for rendering. Next, we set up the render loop for OpenXR!</p>
</section>
</section>
<section id="building-a-renderloop">
<h2>3.2 Building a RenderLoop<a class="headerlink" href="#building-a-renderloop" title="Link to this heading">¶</a></h2>
<p>With most of the OpenXR objects now set up, we can now turn our attention to rendering graphics. There are two further OpenXR objects that are needed to render; pertaining to where the user is and what the user sees of the external environment around them. Namely, these are the ‘reference space’ and the ‘environment blend mode’ respectively.</p>
<p>Then, with those final pieces in place, we can look to the <code class="docutils literal notranslate"><span class="pre">RenderFrame()</span></code> and <code class="docutils literal notranslate"><span class="pre">RenderLayer()</span></code> code to invoke graphics work on the GPU and present it back to OpenXR and its compositor through the use of the composition layers and within the scope of an XR Frame.</p>
<p>Update the methods and members in the class. Copy the highlighted code:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">OpenXRTutorial</span><span class="w"> </span><span class="p">{</span>
<span class="hll"><span class="k">private</span><span class="o">:</span>
</span><span class="hll"><span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">RenderLayerInfo</span><span class="p">;</span>
</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">        </span><span class="c1">// [...] Constructor and Destructor created in previous chapters.</span>

<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="n">Run</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">CreateInstance</span><span class="p">();</span>
<span class="w">                </span><span class="n">CreateDebugMessenger</span><span class="p">();</span>

<span class="w">                </span><span class="n">GetInstanceProperties</span><span class="p">();</span>
<span class="w">                </span><span class="n">GetSystemID</span><span class="p">();</span>

<span class="w">                </span><span class="n">GetViewConfigurationViews</span><span class="p">();</span>
<span class="hll"><span class="w">                </span><span class="n">GetEnvironmentBlendModes</span><span class="p">();</span>
</span>
<span class="w">                </span><span class="n">CreateSession</span><span class="p">();</span>
<span class="hll"><span class="w">                </span><span class="n">CreateReferenceSpace</span><span class="p">();</span>
</span><span class="w">                </span><span class="n">CreateSwapchains</span><span class="p">();</span>

<span class="w">                </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">m_applicationRunning</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                        </span><span class="n">PollSystemEvents</span><span class="p">();</span>
<span class="w">                        </span><span class="n">PollEvents</span><span class="p">();</span>
<span class="w">                        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_sessionRunning</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="hll"><span class="w">                                </span><span class="n">RenderFrame</span><span class="p">();</span>
</span><span class="w">                        </span><span class="p">}</span>
<span class="w">                </span><span class="p">}</span>

<span class="w">                </span><span class="n">DestroySwapchains</span><span class="p">();</span>
<span class="hll"><span class="w">                </span><span class="n">DestroyReferenceSpace</span><span class="p">();</span>
</span><span class="w">                </span><span class="n">DestroySession</span><span class="p">();</span>

<span class="w">                </span><span class="n">DestroyDebugMessenger</span><span class="p">();</span>
<span class="w">                </span><span class="n">DestroyInstance</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
<span class="w">        </span><span class="c1">// [...] Methods created in previous chapters.</span>

<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="n">GetViewConfigurationViews</span><span class="p">()</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">                </span><span class="c1">// [...]</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="n">CreateSwapchains</span><span class="p">()</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">                </span><span class="c1">// [...]</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="n">DestroySwapchains</span><span class="p">()</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">                </span><span class="c1">// [...]</span>
<span class="w">        </span><span class="p">}</span>
<span class="hll"><span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="n">GetEnvironmentBlendModes</span><span class="p">()</span>
</span><span class="hll"><span class="w">        </span><span class="p">{</span>
</span><span class="hll"><span class="w">        </span><span class="p">}</span>
</span><span class="hll"><span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="n">CreateReferenceSpace</span><span class="p">()</span>
</span><span class="hll"><span class="w">        </span><span class="p">{</span>
</span><span class="hll"><span class="w">        </span><span class="p">}</span>
</span><span class="hll"><span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="n">DestroyReferenceSpace</span><span class="p">()</span>
</span><span class="hll"><span class="w">        </span><span class="p">{</span>
</span><span class="hll"><span class="w">        </span><span class="p">}</span>
</span><span class="hll"><span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="n">RenderFrame</span><span class="p">()</span>
</span><span class="hll"><span class="w">        </span><span class="p">{</span>
</span><span class="hll"><span class="w">        </span><span class="p">}</span>
</span><span class="hll"><span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">RenderLayer</span><span class="p">(</span><span class="n">RenderLayerInfo</span><span class="o">&amp;</span><span class="w"> </span><span class="n">renderLayerInfo</span><span class="p">)</span>
</span><span class="hll"><span class="w">        </span><span class="p">{</span>
</span><span class="hll"><span class="w">        </span><span class="p">}</span>
</span><span class="k">private</span><span class="o">:</span>
<span class="w">        </span><span class="c1">// [...] Members created in previous chapters.</span>

<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">XrViewConfigurationType</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m_applicationViewConfigurations</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">XR_VIEW_CONFIGURATION_TYPE_PRIMARY_STEREO</span><span class="p">,</span><span class="w"> </span><span class="n">XR_VIEW_CONFIGURATION_TYPE_PRIMARY_MONO</span><span class="p">};</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">XrViewConfigurationType</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m_viewConfigurations</span><span class="p">;</span>
<span class="w">        </span><span class="n">XrViewConfigurationType</span><span class="w"> </span><span class="n">m_viewConfiguration</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">XR_VIEW_CONFIGURATION_TYPE_MAX_ENUM</span><span class="p">;</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">XrViewConfigurationView</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m_viewConfigurationViews</span><span class="p">;</span>

<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">SwapchainInfo</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">XrSwapchain</span><span class="w"> </span><span class="n">swapchain</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">XR_NULL_HANDLE</span><span class="p">;</span>
<span class="w">                </span><span class="kt">int64_t</span><span class="w"> </span><span class="n">swapchainFormat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">                </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">void</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="n">imageViews</span><span class="p">;</span>
<span class="w">        </span><span class="p">};</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SwapchainInfo</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m_colorSwapchainInfos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SwapchainInfo</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m_depthSwapchainInfos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>

<span class="hll"><span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">XrEnvironmentBlendMode</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m_applicationEnvironmentBlendModes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">XR_ENVIRONMENT_BLEND_MODE_OPAQUE</span><span class="p">,</span><span class="w"> </span><span class="n">XR_ENVIRONMENT_BLEND_MODE_ADDITIVE</span><span class="p">};</span>
</span><span class="hll"><span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">XrEnvironmentBlendMode</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m_environmentBlendModes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
</span><span class="hll"><span class="w">        </span><span class="n">XrEnvironmentBlendMode</span><span class="w"> </span><span class="n">m_environmentBlendMode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">XR_ENVIRONMENT_BLEND_MODE_MAX_ENUM</span><span class="p">;</span>
</span><span class="hll">
</span><span class="hll"><span class="w">        </span><span class="n">XrSpace</span><span class="w"> </span><span class="n">m_localSpace</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">XR_NULL_HANDLE</span><span class="p">;</span>
</span><span class="hll"><span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">RenderLayerInfo</span><span class="w"> </span><span class="p">{</span>
</span><span class="hll"><span class="w">                </span><span class="n">XrTime</span><span class="w"> </span><span class="n">predictedDisplayTime</span><span class="p">;</span>
</span><span class="hll"><span class="w">                </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">XrCompositionLayerBaseHeader</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="n">layers</span><span class="p">;</span>
</span><span class="hll"><span class="w">                </span><span class="n">XrCompositionLayerProjection</span><span class="w"> </span><span class="n">layerProjection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">XR_TYPE_COMPOSITION_LAYER_PROJECTION</span><span class="p">};</span>
</span><span class="hll"><span class="w">                </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">XrCompositionLayerProjectionView</span><span class="o">&gt;</span><span class="w"> </span><span class="n">layerProjectionViews</span><span class="p">;</span>
</span><span class="hll"><span class="w">        </span><span class="p">};</span>
</span><span class="p">};</span>
</pre></div>
</div>
<section id="environment-blend-modes">
<h3>3.2.1 Environment Blend Modes<a class="headerlink" href="#environment-blend-modes" title="Link to this heading">¶</a></h3>
<p>Some XR experiences rely on blending the real world and rendered graphics together. Choosing the correct environment blend mode is vital for creating immersion in both virtual and augmented realities.</p>
<p>This blending is done at the final stage after the compositor has flattened and blended all the compositing layers passed to OpenXR at the end of the XR frame.</p>
<p>The enum <cite>XrEnvironmentBlendMode</cite> describes how OpenXR should blend the rendered view(s) with the external environment behind the screen(s). The values are:</p>
<blockquote>
<div><ul class="simple">
<li><p>VR: <code class="docutils literal notranslate"><span class="pre">XR_ENVIRONMENT_BLEND_MODE_OPAQUE</span></code> is the virtual reality case, where the real world is obscured.</p></li>
<li><p>AR: <code class="docutils literal notranslate"><span class="pre">XR_ENVIRONMENT_BLEND_MODE_ADDITIVE</span></code> or <code class="docutils literal notranslate"><span class="pre">XR_ENVIRONMENT_BLEND_MODE_ALPHA_BLEND</span></code> are used to composite rendered images with the external environment.</p></li>
</ul>
</div></blockquote>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>XrEnvironmentBlendMode</p></td>
<td><p>Description</p></td>
</tr>
<tr class="row-even"><td><p>XR_ENVIRONMENT_BLEND_MODE_OPAQUE</p></td>
<td><p>The composition layers will be displayed with no view of the physical world behind them.
The composited image will be interpreted as an RGB image, ignoring the composited alpha channel.</p></td>
</tr>
<tr class="row-odd"><td><p>XR_ENVIRONMENT_BLEND_MODE_ADDITIVE</p></td>
<td><p>The composition layers will be additively blended with the real world behind the display.
The composited image will be interpreted as an RGB image, ignoring the composited alpha channel during the additive blending.
This will cause black composited pixels to appear transparent.</p></td>
</tr>
<tr class="row-even"><td><p>XR_ENVIRONMENT_BLEND_MODE_ALPHA_BLEND</p></td>
<td><p>The composition layers will be alpha-blended with the real world behind the display.
The composited image will be interpreted as an RGBA image, with the composited alpha channel determining each pixel’s
level of blending with the real world behind the display.</p></td>
</tr>
</tbody>
</table>
<p><a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/html/xrspec.html#compositing">XrEnvironmentBlendMode - Enumerant Descriptions</a>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="nc">XrEnvironmentBlendMode</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">XR_ENVIRONMENT_BLEND_MODE_OPAQUE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">    </span><span class="n">XR_ENVIRONMENT_BLEND_MODE_ADDITIVE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>
<span class="w">    </span><span class="n">XR_ENVIRONMENT_BLEND_MODE_ALPHA_BLEND</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span>
<span class="w">    </span><span class="n">XR_ENVIRONMENT_BLEND_MODE_MAX_ENUM</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x7FFFFFFF</span>
<span class="p">}</span><span class="w"> </span><span class="n">XrEnvironmentBlendMode</span><span class="p">;</span>
</pre></div>
</div>
<p><em>The above code is an excerpt from openxr/openxr.h</em></p>
<p>Copy the following code into the <code class="docutils literal notranslate"><span class="pre">GetEnvironmentBlendModes()</span></code> method:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Retrieves the available blend modes. The first call gets the count of the array that will be returned. The next call fills out the array.</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">environmentBlendModeCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">OPENXR_CHECK</span><span class="p">(</span><span class="n">xrEnumerateEnvironmentBlendModes</span><span class="p">(</span><span class="n">m_xrInstance</span><span class="p">,</span><span class="w"> </span><span class="n">m_systemID</span><span class="p">,</span><span class="w"> </span><span class="n">m_viewConfiguration</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">environmentBlendModeCount</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Failed to enumerate EnvironmentBlend Modes.&quot;</span><span class="p">);</span>
<span class="n">m_environmentBlendModes</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">environmentBlendModeCount</span><span class="p">);</span>
<span class="n">OPENXR_CHECK</span><span class="p">(</span><span class="n">xrEnumerateEnvironmentBlendModes</span><span class="p">(</span><span class="n">m_xrInstance</span><span class="p">,</span><span class="w"> </span><span class="n">m_systemID</span><span class="p">,</span><span class="w"> </span><span class="n">m_viewConfiguration</span><span class="p">,</span><span class="w"> </span><span class="n">environmentBlendModeCount</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">environmentBlendModeCount</span><span class="p">,</span><span class="w"> </span><span class="n">m_environmentBlendModes</span><span class="p">.</span><span class="n">data</span><span class="p">()),</span><span class="w"> </span><span class="s">&quot;Failed to enumerate EnvironmentBlend Modes.&quot;</span><span class="p">);</span>

<span class="c1">// Pick the first application supported blend mode supported by the hardware.</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">XrEnvironmentBlendMode</span><span class="w"> </span><span class="o">&amp;</span><span class="n">environmentBlendMode</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">m_applicationEnvironmentBlendModes</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">m_environmentBlendModes</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">m_environmentBlendModes</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="n">environmentBlendMode</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">m_environmentBlendModes</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">m_environmentBlendMode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">environmentBlendMode</span><span class="p">;</span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_environmentBlendMode</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">XR_ENVIRONMENT_BLEND_MODE_MAX_ENUM</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">XR_TUT_LOG_ERROR</span><span class="p">(</span><span class="s">&quot;Failed to find a compatible blend mode. Defaulting to XR_ENVIRONMENT_BLEND_MODE_OPAQUE.&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">m_environmentBlendMode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">XR_ENVIRONMENT_BLEND_MODE_OPAQUE</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We enumerated the environment blend modes as shown above. This function took a pointer to the first element in an array of <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrEnvironmentBlendMode.html">XrEnvironmentBlendMode</a> s as multiple environment blend modes could be available to the system. The runtime returned an array ordered by its preference for the system. After we enumerated all the <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrEnvironmentBlendMode.html">XrEnvironmentBlendMode</a> s,  we looped through all of our <code class="docutils literal notranslate"><span class="pre">m_applicationEnvironmentBlendModes</span></code> to try and find one in our <code class="docutils literal notranslate"><span class="pre">m_environmentBlendModes</span></code>, if we can’t find one, we default to <code class="docutils literal notranslate"><span class="pre">XR_ENVIRONMENT_BLEND_MODE_OPAQUE</span></code>, assigning the result to <code class="docutils literal notranslate"><span class="pre">m_environmentBlendMode</span></code>.</p>
</section>
<section id="reference-spaces">
<h3>3.2.2 Reference Spaces<a class="headerlink" href="#reference-spaces" title="Link to this heading">¶</a></h3>
<p>Now that OpenXR knows what the user should see, we need to tell OpenXR about the user’s viewpoint. This is where the reference space comes in. Copy the following code into the <code class="docutils literal notranslate"><span class="pre">CreateReferenceSpace()</span></code> method:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Fill out an XrReferenceSpaceCreateInfo structure and create a reference XrSpace, specifying a Local space with an identity pose as the origin.</span>
<span class="n">XrReferenceSpaceCreateInfo</span><span class="w"> </span><span class="n">referenceSpaceCI</span><span class="p">{</span><span class="n">XR_TYPE_REFERENCE_SPACE_CREATE_INFO</span><span class="p">};</span>
<span class="n">referenceSpaceCI</span><span class="p">.</span><span class="n">referenceSpaceType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">XR_REFERENCE_SPACE_TYPE_LOCAL</span><span class="p">;</span>
<span class="n">referenceSpaceCI</span><span class="p">.</span><span class="n">poseInReferenceSpace</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{{</span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">}};</span>
<span class="n">OPENXR_CHECK</span><span class="p">(</span><span class="n">xrCreateReferenceSpace</span><span class="p">(</span><span class="n">m_session</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">referenceSpaceCI</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">m_localSpace</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Failed to create ReferenceSpace.&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>We fill out a <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrReferenceSpaceCreateInfo.html">XrReferenceSpaceCreateInfo</a> structure. The first member is of type <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrReferenceSpaceType.html">XrReferenceSpaceType</a>, which we will discuss shortly.</p>
<p>When we create the <em>reference space</em>, we need to specify an <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrPosef.html">XrPosef</a>, which will be the origin transform of the space. In this case, we will set <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrReferenceSpaceCreateInfo.html">XrReferenceSpaceCreateInfo</a> <code class="docutils literal notranslate"><span class="pre">::poseInReferenceSpace</span></code> to an “identity” pose - an identity quaternion and a zero position.</p>
<p>If we specify a different pose, the origin received when we poll the space would be offset from the default origin the runtime defines for that space type.</p>
<p>An <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrSpace.html">XrSpace</a> is a frame of reference defined not by its instantaneous values, but semantically by its purpose and relationship to other spaces. The actual, instantaneous position and orientation of an <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrSpace.html">XrSpace</a> is called its <em>pose</em>.</p>
<figure class="align-center">
<a class="reference internal image-reference" href="_images/ViewSpace.png"><img alt="OpenXR Reference Space View" src="_images/ViewSpace.png" style="width: 50%;" /></a>
</figure>
<p>One kind of reference space is view space (<code class="docutils literal notranslate"><span class="pre">XR_REFERENCE_SPACE_TYPE_VIEW</span></code>), which is oriented with the user’s head, and is useful for user interfaces and many other purposes. We don’t use it to generate view matrices for rendering, because those are often offset from the view space due to stereo rendering.</p>
<p>The View Reference Space uses the view origin (or the centroid of the views in the case of stereo) as the origin of the space. +Y is up, +X is to the right, and -Z is forward. The space is aligned in front of the viewer and it is not gravity aligned. It is most often used for rendering small head-locked content like a HUD (Head-up display).</p>
<figure class="align-center">
<a class="reference internal image-reference" href="_images/LocalSpace.png"><img alt="OpenXR Reference Space Local" src="_images/LocalSpace.png" style="width: 50%;" /></a>
</figure>
<p>By using <code class="docutils literal notranslate"><span class="pre">XR_REFERENCE_SPACE_TYPE_LOCAL</span></code> we specify that the views are relative to the XR hardware’s ‘local’ space - either the headset’s starting position or some other world-locked origin.</p>
<p>The Local Reference Space uses an initial location to establish a world-locked, gravity-aligned point as the origin of the space. +Y is up,+X is to the right, and -Z is forward. The origin is also locked for pitch(x) and roll(z). The initial position may be established at the application start up or from a calibrated origin point.</p>
<p>It may be used for rendering seated-scale experiences such as driving or aircraft simulation, where a virtual floor is not required. When recentering, the runtime will queue a <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrEventDataReferenceSpaceChangePending.html">XrEventDataReferenceSpaceChangePending</a> structure for the application to process.</p>
<figure class="align-center">
<a class="reference internal image-reference" href="_images/StageSpace.png"><img alt="OpenXR Reference Space Stage" src="_images/StageSpace.png" style="width: 80%;" /></a>
</figure>
<p>Some devices support stage space (<code class="docutils literal notranslate"><span class="pre">XR_REFERENCE_SPACE_TYPE_STAGE</span></code>); this implies a roomscale space, e.g. with its origin on the floor.</p>
<p>The Stage Reference Space defines a rectangular area that is flat and devoid of obstructions. The origin is defined to be on the floor and at the center of the rectangular area. +Y is up, +X is to the right, and -Z is forward. The origin is axis-aligned to the XZ plane. It is most often used for rendering standing-scale experiences (no bounds) or roomscale experiences (with bounds) where a physical floor is required. When the user is redefining the origin or bounds of the area, the runtime will queue a <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrEventDataReferenceSpaceChangePending.html">XrEventDataReferenceSpaceChangePending</a> structure for the application to process.</p>
<p>For more information on reference spaces see <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/html/xrspec.html#reference-spaces">the OpenXR Specification</a>.</p>
<figure class="align-left">
<a class="reference internal image-reference" href="_images/OpenXR-Coordinate-System.png"><img alt="OpenXR Default Coordinate System" src="_images/OpenXR-Coordinate-System.png" style="width: 100%;" /></a>
</figure>
<p>The default coordinate system in OpenXR is right-handed with +Y up, +X to the right, and -Z forward.</p>
<p>The XR_EXT_local_floor extension bridges the use-case of applications wanting to use a seated-scale experience, but also with a physical floor. Neither <code class="docutils literal notranslate"><span class="pre">XR_REFERENCE_SPACE_TYPE_LOCAL</span></code> nor <code class="docutils literal notranslate"><span class="pre">XR_REFERENCE_SPACE_TYPE_STAGE</span></code> truly fits this requirement.</p>
<p>The Local Floor Reference Space establishes a world-locked, gravity-aligned point as the origin of the space. +Y is up, +X is to the right, and -Z is forward. The origin is the same as <code class="docutils literal notranslate"><span class="pre">XR_REFERENCE_SPACE_TYPE_LOCAL</span></code> in the X and Z coordinates, but not the Y coordinate. See more here: <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/html/xrspec.html#XR_EXT_local_floor">12.34. XR_EXT_local_floor</a>.</p>
<p>You may wish to call <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/xrEnumerateReferenceSpaces.html">xrEnumerateReferenceSpaces</a> to get all <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrReferenceSpaceType.html">XrReferenceSpaceType</a> s available to the system, before choosing one that is suitable for your application and the user’s environment.</p>
<p>At the end of the application, we should destroy the <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrSpace.html">XrSpace</a> by calling <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/xrDestroySpace.html">xrDestroySpace</a>. If successful, the function will return <code class="docutils literal notranslate"><span class="pre">XR_SUCCESS</span></code>. Copy the following code into the <code class="docutils literal notranslate"><span class="pre">DestroyReferenceSpace()</span></code> method:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Destroy the reference XrSpace.</span>
<span class="n">OPENXR_CHECK</span><span class="p">(</span><span class="n">xrDestroySpace</span><span class="p">(</span><span class="n">m_localSpace</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Failed to destroy Space.&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="rendering-a-frame">
<h3>3.2.3 Rendering a Frame<a class="headerlink" href="#rendering-a-frame" title="Link to this heading">¶</a></h3>
<p>Below is the code needed for rendering a frame in OpenXR. For each frame, we sequence through the three primary functions: <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/xrWaitFrame.html">xrWaitFrame</a>, <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/xrBeginFrame.html">xrBeginFrame</a> and <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/xrEndFrame.html">xrEndFrame</a>. These functions wrap around our rendering code and communicate to the OpenXR runtime that we are rendering and that we need to synchronize with the XR compositor. Copy the following code into <code class="docutils literal notranslate"><span class="pre">RenderFrame()</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Get the XrFrameState for timing and rendering info.</span>
<span class="n">XrFrameState</span><span class="w"> </span><span class="n">frameState</span><span class="p">{</span><span class="n">XR_TYPE_FRAME_STATE</span><span class="p">};</span>
<span class="n">XrFrameWaitInfo</span><span class="w"> </span><span class="n">frameWaitInfo</span><span class="p">{</span><span class="n">XR_TYPE_FRAME_WAIT_INFO</span><span class="p">};</span>
<span class="n">OPENXR_CHECK</span><span class="p">(</span><span class="n">xrWaitFrame</span><span class="p">(</span><span class="n">m_session</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">frameWaitInfo</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">frameState</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Failed to wait for XR Frame.&quot;</span><span class="p">);</span>

<span class="c1">// Tell the OpenXR compositor that the application is beginning the frame.</span>
<span class="n">XrFrameBeginInfo</span><span class="w"> </span><span class="n">frameBeginInfo</span><span class="p">{</span><span class="n">XR_TYPE_FRAME_BEGIN_INFO</span><span class="p">};</span>
<span class="n">OPENXR_CHECK</span><span class="p">(</span><span class="n">xrBeginFrame</span><span class="p">(</span><span class="n">m_session</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">frameBeginInfo</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Failed to begin the XR Frame.&quot;</span><span class="p">);</span>

<span class="c1">// Variables for rendering and layer composition.</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">rendered</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="n">RenderLayerInfo</span><span class="w"> </span><span class="n">renderLayerInfo</span><span class="p">;</span>
<span class="n">renderLayerInfo</span><span class="p">.</span><span class="n">predictedDisplayTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">frameState</span><span class="p">.</span><span class="n">predictedDisplayTime</span><span class="p">;</span>

<span class="c1">// Check that the session is active and that we should render.</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">sessionActive</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">m_sessionState</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">XR_SESSION_STATE_SYNCHRONIZED</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">m_sessionState</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">XR_SESSION_STATE_VISIBLE</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">m_sessionState</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">XR_SESSION_STATE_FOCUSED</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sessionActive</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">frameState</span><span class="p">.</span><span class="n">shouldRender</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Render the stereo image and associate one of swapchain images with the XrCompositionLayerProjection structure.</span>
<span class="w">    </span><span class="n">rendered</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RenderLayer</span><span class="p">(</span><span class="n">renderLayerInfo</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rendered</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">renderLayerInfo</span><span class="p">.</span><span class="n">layers</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">XrCompositionLayerBaseHeader</span><span class="w"> </span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">renderLayerInfo</span><span class="p">.</span><span class="n">layerProjection</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Tell OpenXR that we are finished with this frame; specifying its display time, environment blending and layers.</span>
<span class="n">XrFrameEndInfo</span><span class="w"> </span><span class="n">frameEndInfo</span><span class="p">{</span><span class="n">XR_TYPE_FRAME_END_INFO</span><span class="p">};</span>
<span class="n">frameEndInfo</span><span class="p">.</span><span class="n">displayTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">frameState</span><span class="p">.</span><span class="n">predictedDisplayTime</span><span class="p">;</span>
<span class="n">frameEndInfo</span><span class="p">.</span><span class="n">environmentBlendMode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_environmentBlendMode</span><span class="p">;</span>
<span class="n">frameEndInfo</span><span class="p">.</span><span class="n">layerCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">renderLayerInfo</span><span class="p">.</span><span class="n">layers</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
<span class="n">frameEndInfo</span><span class="p">.</span><span class="n">layers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">renderLayerInfo</span><span class="p">.</span><span class="n">layers</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
<span class="n">OPENXR_CHECK</span><span class="p">(</span><span class="n">xrEndFrame</span><span class="p">(</span><span class="n">m_session</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">frameEndInfo</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Failed to end the XR Frame.&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>The primary structure in use here is the <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrFrameState.html">XrFrameState</a>, which contains vital members for timing and rendering such as the <code class="docutils literal notranslate"><span class="pre">predictedDisplayTime</span></code> member, which is the predicted time that the frame will be displayed to the user, and the <code class="docutils literal notranslate"><span class="pre">shouldRender</span></code> member, which states whether the application should render any graphics. This last member could change when the application is transitioning into or out of a running session or when the system UI is focused and covering the application.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">XrFrameState</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">XrStructureType</span><span class="w">       </span><span class="n">type</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">XR_MAY_ALIAS</span><span class="w">    </span><span class="n">next</span><span class="p">;</span>
<span class="w">    </span><span class="n">XrTime</span><span class="w">                </span><span class="n">predictedDisplayTime</span><span class="p">;</span>
<span class="w">    </span><span class="n">XrDuration</span><span class="w">            </span><span class="n">predictedDisplayPeriod</span><span class="p">;</span>
<span class="w">    </span><span class="n">XrBool32</span><span class="w">              </span><span class="n">shouldRender</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">XrFrameState</span><span class="p">;</span>
</pre></div>
</div>
<p><em>The above code is an excerpt from openxr/openxr.h</em></p>
<p><a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/xrWaitFrame.html">xrWaitFrame</a>, <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/xrBeginFrame.html">xrBeginFrame</a> and <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/xrEndFrame.html">xrEndFrame</a> <em>must</em> wrap around all the rendering in the XR frame and <em>must</em> be called in that sequence. <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/xrWaitFrame.html">xrWaitFrame</a> provides to the application the information for the frame, which we’ve discussed above. <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/xrWaitFrame.html">xrWaitFrame</a> will throttle the frame loop to synchronize the frame submissions with the display. Next, <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/xrBeginFrame.html">xrBeginFrame</a> should be called just before executing any GPU work for the frame. When calling <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/xrEndFrame.html">xrEndFrame</a>, we need to pass an <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrFrameEndInfo.html">XrFrameEndInfo</a> structure to that function. We assign <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrFrameState.html">XrFrameState</a> <code class="docutils literal notranslate"><span class="pre">::predictedDisplayTime</span></code> to <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrFrameEndInfo.html">XrFrameEndInfo</a> <code class="docutils literal notranslate"><span class="pre">::displayTime</span></code>. It should be noted that we can modify this value during the frame. Next, we assign to <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrFrameEndInfo.html">XrFrameEndInfo</a> <code class="docutils literal notranslate"><span class="pre">::environmentBlendMode</span></code> our selected blend mode. Last, we assign the count of and a pointer to an <code class="docutils literal notranslate"><span class="pre">std::vector&lt;XrCompositionLayerBaseHeader</span> <span class="pre">*&gt;</span></code> which is a member of our <code class="docutils literal notranslate"><span class="pre">RenderLayerInfo</span></code> struct. Reference: <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrCompositionLayerBaseHeader.html">XrCompositionLayerBaseHeader</a>. These Composition Layers are assembled by the OpenXR compositor to create the final images.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">XrFrameEndInfo</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">XrStructureType</span><span class="w">                               </span><span class="n">type</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">XR_MAY_ALIAS</span><span class="w">                      </span><span class="n">next</span><span class="p">;</span>
<span class="w">    </span><span class="n">XrTime</span><span class="w">                                        </span><span class="n">displayTime</span><span class="p">;</span>
<span class="w">    </span><span class="n">XrEnvironmentBlendMode</span><span class="w">                        </span><span class="n">environmentBlendMode</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                                      </span><span class="n">layerCount</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">XrCompositionLayerBaseHeader</span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w">    </span><span class="n">layers</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">XrFrameEndInfo</span><span class="p">;</span>
</pre></div>
</div>
<p><em>The above code is an excerpt from openxr/openxr.h</em></p>
<p><a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrCompositionLayerBaseHeader.html">XrCompositionLayerBaseHeader</a> is the base structure from which all other <code class="docutils literal notranslate"><span class="pre">XrCompositionLayer...</span></code> types extend. They describe the type of layer to be composited along with the relevant information. If we have rendered any graphics within this frame, we cast the memory address our <code class="docutils literal notranslate"><span class="pre">XrCompositionLayer...</span></code> structure to an <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrCompositionLayerBaseHeader.html">XrCompositionLayerBaseHeader</a> pointer and push it into <code class="docutils literal notranslate"><span class="pre">std::vector&lt;XrCompositionLayerBaseHeader</span> <span class="pre">*&gt;</span></code>, all of these variables are found within our <code class="docutils literal notranslate"><span class="pre">RenderLayerInfo</span></code> struct. These will be assigned in our <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrFrameEndInfo.html">XrFrameEndInfo</a> structure.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">XR_MAY_ALIAS</span><span class="w"> </span><span class="n">XrCompositionLayerBaseHeader</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">XrStructureType</span><span class="w">             </span><span class="n">type</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">XR_MAY_ALIAS</span><span class="w">    </span><span class="n">next</span><span class="p">;</span>
<span class="w">    </span><span class="n">XrCompositionLayerFlags</span><span class="w">     </span><span class="n">layerFlags</span><span class="p">;</span>
<span class="w">    </span><span class="n">XrSpace</span><span class="w">                     </span><span class="n">space</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">XrCompositionLayerBaseHeader</span><span class="p">;</span>
</pre></div>
</div>
<p><em>The above code is an excerpt from openxr/openxr.h</em></p>
<p>Below is a table of the <code class="docutils literal notranslate"><span class="pre">XrCompositionLayer...</span></code> types provided by the OpenXR 1.0 Core Specification and <code class="docutils literal notranslate"><span class="pre">XR_KHR_composition_layer_...</span></code> extensions.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 22.9%" />
<col style="width: 20.5%" />
<col style="width: 56.6%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Extension</p></td>
<td><p>Structure</p></td>
<td><p>Description</p></td>
</tr>
<tr class="row-even"><td><p>OpenXR 1.0 Core Specification</p></td>
<td><p><a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrCompositionLayerProjection.html">XrCompositionLayerProjection</a></p></td>
<td><p>It’s used for rendering 3D Graphical elements.</p></td>
</tr>
<tr class="row-odd"><td><p>OpenXR 1.0 Core Specification</p></td>
<td><p><a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrCompositionLayerQuad.html">XrCompositionLayerQuad</a></p></td>
<td><p>It’s used for rendering 2D or GUI elements.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XR_KHR_composition_layer_cube.html">XR_KHR_composition_layer_cube</a></p></td>
<td><p><a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrCompositionLayerCubeKHR.html">XrCompositionLayerCubeKHR</a></p></td>
<td><p>It’s used for rendering Environment Cubemps.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XR_KHR_composition_layer_depth.html">XR_KHR_composition_layer_depth</a></p></td>
<td><p><a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrCompositionLayerDepthInfoKHR.html">XrCompositionLayerDepthInfoKHR</a></p></td>
<td><p>It allows the submission of a depth image with the projection layer for more accurate reprojections.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XR_KHR_composition_layer_cylinder.html">XR_KHR_composition_layer_cylinder</a></p></td>
<td><p><a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrCompositionLayerCylinderKHR.html">XrCompositionLayerCylinderKHR</a></p></td>
<td><p>It allows a flat texture to be rendered on inside of a cylinder section - like a curved display.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XR_KHR_composition_layer_equirect.html">XR_KHR_composition_layer_equirect</a></p></td>
<td><p><a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrCompositionLayerEquirectKHR.html">XrCompositionLayerEquirectKHR</a></p></td>
<td><p>It’s used for rendering an equirectangular image onto the inside of sphere - like a cubemap.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XR_KHR_composition_layer_color_scale_bias.html">XR_KHR_composition_layer_color_scale_bias</a></p></td>
<td><p><a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrCompositionLayerColorScaleBiasKHR.html">XrCompositionLayerColorScaleBiasKHR</a></p></td>
<td><p>A color transform applied to an existing composition layer. It could be used to highlight something to the user.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XR_KHR_composition_layer_equirect2.html">XR_KHR_composition_layer_equirect2</a></p></td>
<td><p><a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrCompositionLayerEquirect2KHR.html">XrCompositionLayerEquirect2KHR</a></p></td>
<td><p>Like <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrCompositionLayerEquirectKHR.html">XrCompositionLayerEquirectKHR</a>, but uses different parameters similar to <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XR_KHR_composition_layer_cylinder.html">XR_KHR_composition_layer_cylinder</a>.</p></td>
</tr>
</tbody>
</table>
<p>Other hardware vendor specific extensions relating to <code class="docutils literal notranslate"><span class="pre">XrCompositionLayer...</span></code> are also in the OpenXR 1.0 specification.</p>
<p>In our <code class="docutils literal notranslate"><span class="pre">RenderLayerInfo</span></code> struct, we have used a single <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrCompositionLayerProjection.html">XrCompositionLayerProjection</a>. The structure describes the <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrCompositionLayerFlags.html">XrCompositionLayerFlags</a>, an <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrSpace.html">XrSpace</a> and a count and pointer to an array of <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrCompositionLayerProjectionView.html">XrCompositionLayerProjectionView</a>.</p>
<p><a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrCompositionLayerProjectionView.html">XrCompositionLayerProjectionView</a> describes the <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrPosef.html">XrPosef</a> of the view relative to the reference space, the field of view and to which <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrSwapchainSubImage.html">XrSwapchainSubImage</a> the view relates.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">XrSwapchainSubImage</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">XrSwapchain</span><span class="w">    </span><span class="n">swapchain</span><span class="p">;</span>
<span class="w">    </span><span class="n">XrRect2Di</span><span class="w">      </span><span class="n">imageRect</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">       </span><span class="n">imageArrayIndex</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">XrSwapchainSubImage</span><span class="p">;</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">XrCompositionLayerProjectionView</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">XrStructureType</span><span class="w">             </span><span class="n">type</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">XR_MAY_ALIAS</span><span class="w">    </span><span class="n">next</span><span class="p">;</span>
<span class="w">    </span><span class="n">XrPosef</span><span class="w">                     </span><span class="n">pose</span><span class="p">;</span>
<span class="w">    </span><span class="n">XrFovf</span><span class="w">                      </span><span class="n">fov</span><span class="p">;</span>
<span class="w">    </span><span class="n">XrSwapchainSubImage</span><span class="w">         </span><span class="n">subImage</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">XrCompositionLayerProjectionView</span><span class="p">;</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">XrCompositionLayerProjection</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">XrStructureType</span><span class="w">                            </span><span class="n">type</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">XR_MAY_ALIAS</span><span class="w">                   </span><span class="n">next</span><span class="p">;</span>
<span class="w">    </span><span class="n">XrCompositionLayerFlags</span><span class="w">                    </span><span class="n">layerFlags</span><span class="p">;</span>
<span class="w">    </span><span class="n">XrSpace</span><span class="w">                                    </span><span class="n">space</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                                   </span><span class="n">viewCount</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">XrCompositionLayerProjectionView</span><span class="o">*</span><span class="w">    </span><span class="n">views</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">XrCompositionLayerProjection</span><span class="p">;</span>
</pre></div>
</div>
<p><em>The above code is an excerpt from openxr/openxr.h</em></p>
<p>The compositing of layers can be set on a per-layer basis through the use of the per-texel alpha channel. This is done through the use of the <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrCompositionLayerFlags.html">XrCompositionLayerFlags</a> member. Below is a description of these flags.</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>XrCompositionLayerFlags</p></td>
<td><p>Descriptions</p></td>
</tr>
<tr class="row-even"><td><p>XR_COMPOSITION_LAYER_CORRECT_CHROMATIC_ABERRATION_BIT</p></td>
<td><p>Enables chromatic aberration correction if not already done. It is planned to be deprecated in OpenXR 1.1</p></td>
</tr>
<tr class="row-odd"><td><p>XR_COMPOSITION_LAYER_BLEND_TEXTURE_SOURCE_ALPHA_BIT</p></td>
<td><p>Enables the layer texture’s alpha channel for blending</p></td>
</tr>
<tr class="row-even"><td><p>XR_COMPOSITION_LAYER_UNPREMULTIPLIED_ALPHA_BIT</p></td>
<td><p>States that the color channels have not been pre-multiplied with alpha for transparency</p></td>
</tr>
</tbody>
</table>
<p>See more here: <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/html/xrspec.html#composition-layer-flags">10.6.1. Composition Layer Flags</a>.</p>
<p>Before we call <code class="docutils literal notranslate"><span class="pre">RenderLayer()</span></code>, we check that the <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrSession.html">XrSession</a> is active, as we don’t want to needlessly render graphics, and we also check whether OpenXR wants us to render via the use of <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrFrameState.html">XrFrameState</a> <code class="docutils literal notranslate"><span class="pre">::shouldRender</span></code>.</p>
</section>
<section id="rendering-layers">
<h3>3.2.4 Rendering Layers<a class="headerlink" href="#rendering-layers" title="Link to this heading">¶</a></h3>
<p>From the <code class="docutils literal notranslate"><span class="pre">RenderFrame()</span></code> function we call <code class="docutils literal notranslate"><span class="pre">RenderLayer()</span></code>. Here, we locate the views within the reference space, render to our swapchain images and fill out the <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrCompositionLayerProjection.html">XrCompositionLayerProjection</a> and <code class="docutils literal notranslate"><span class="pre">std::vector&lt;XrCompositionLayerProjectionView&gt;</span></code> members in the <code class="docutils literal notranslate"><span class="pre">RenderLayerInfo</span></code> parameter. Copy the two following blocks of code into the <code class="docutils literal notranslate"><span class="pre">RenderLayer()</span></code> method:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="c1">// Locate the views from the view configuration within the (reference) space at the display time.</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">XrView</span><span class="o">&gt;</span><span class="w"> </span><span class="n">views</span><span class="p">(</span><span class="n">m_viewConfigurationViews</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="w"> </span><span class="p">{</span><span class="n">XR_TYPE_VIEW</span><span class="p">});</span>

<span class="w">    </span><span class="n">XrViewState</span><span class="w"> </span><span class="n">viewState</span><span class="p">{</span><span class="n">XR_TYPE_VIEW_STATE</span><span class="p">};</span><span class="w">  </span><span class="c1">// Will contain information on whether the position and/or orientation is valid and/or tracked.</span>
<span class="w">    </span><span class="n">XrViewLocateInfo</span><span class="w"> </span><span class="n">viewLocateInfo</span><span class="p">{</span><span class="n">XR_TYPE_VIEW_LOCATE_INFO</span><span class="p">};</span>
<span class="w">    </span><span class="n">viewLocateInfo</span><span class="p">.</span><span class="n">viewConfigurationType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_viewConfiguration</span><span class="p">;</span>
<span class="w">    </span><span class="n">viewLocateInfo</span><span class="p">.</span><span class="n">displayTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">renderLayerInfo</span><span class="p">.</span><span class="n">predictedDisplayTime</span><span class="p">;</span>
<span class="w">    </span><span class="n">viewLocateInfo</span><span class="p">.</span><span class="n">space</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_localSpace</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">viewCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">XrResult</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xrLocateViews</span><span class="p">(</span><span class="n">m_session</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">viewLocateInfo</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">viewState</span><span class="p">,</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">views</span><span class="p">.</span><span class="n">size</span><span class="p">()),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">viewCount</span><span class="p">,</span><span class="w"> </span><span class="n">views</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">XR_SUCCESS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">XR_TUT_LOG</span><span class="p">(</span><span class="s">&quot;Failed to locate Views.&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Resize the layer projection views to match the view count. The layer projection views are used in the layer projection.</span>
<span class="w">    </span><span class="n">renderLayerInfo</span><span class="p">.</span><span class="n">layerProjectionViews</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">viewCount</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">XR_TYPE_COMPOSITION_LAYER_PROJECTION_VIEW</span><span class="p">});</span>

<span class="w">    </span><span class="c1">// Per view in the view configuration:</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">viewCount</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">SwapchainInfo</span><span class="w"> </span><span class="o">&amp;</span><span class="n">colorSwapchainInfo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_colorSwapchainInfos</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">        </span><span class="n">SwapchainInfo</span><span class="w"> </span><span class="o">&amp;</span><span class="n">depthSwapchainInfo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_depthSwapchainInfos</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

<span class="w">        </span><span class="c1">// Acquire and wait for an image from the swapchains.</span>
<span class="w">        </span><span class="c1">// Get the image index of an image in the swapchains.</span>
<span class="w">        </span><span class="c1">// The timeout is infinite.</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">colorImageIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">depthImageIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="n">XrSwapchainImageAcquireInfo</span><span class="w"> </span><span class="n">acquireInfo</span><span class="p">{</span><span class="n">XR_TYPE_SWAPCHAIN_IMAGE_ACQUIRE_INFO</span><span class="p">};</span>
<span class="w">        </span><span class="n">OPENXR_CHECK</span><span class="p">(</span><span class="n">xrAcquireSwapchainImage</span><span class="p">(</span><span class="n">colorSwapchainInfo</span><span class="p">.</span><span class="n">swapchain</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">acquireInfo</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">colorImageIndex</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Failed to acquire Image from the Color Swapchian&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">OPENXR_CHECK</span><span class="p">(</span><span class="n">xrAcquireSwapchainImage</span><span class="p">(</span><span class="n">depthSwapchainInfo</span><span class="p">.</span><span class="n">swapchain</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">acquireInfo</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">depthImageIndex</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Failed to acquire Image from the Depth Swapchian&quot;</span><span class="p">);</span>

<span class="w">        </span><span class="n">XrSwapchainImageWaitInfo</span><span class="w"> </span><span class="n">waitInfo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">XR_TYPE_SWAPCHAIN_IMAGE_WAIT_INFO</span><span class="p">};</span>
<span class="w">        </span><span class="n">waitInfo</span><span class="p">.</span><span class="n">timeout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">XR_INFINITE_DURATION</span><span class="p">;</span>
<span class="w">        </span><span class="n">OPENXR_CHECK</span><span class="p">(</span><span class="n">xrWaitSwapchainImage</span><span class="p">(</span><span class="n">colorSwapchainInfo</span><span class="p">.</span><span class="n">swapchain</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">waitInfo</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Failed to wait for Image from the Color Swapchain&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">OPENXR_CHECK</span><span class="p">(</span><span class="n">xrWaitSwapchainImage</span><span class="p">(</span><span class="n">depthSwapchainInfo</span><span class="p">.</span><span class="n">swapchain</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">waitInfo</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Failed to wait for Image from the Depth Swapchain&quot;</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// Get the width and height and construct the viewport and scissors.</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">&amp;</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_viewConfigurationViews</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">recommendedImageRectWidth</span><span class="p">;</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">&amp;</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_viewConfigurationViews</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">recommendedImageRectHeight</span><span class="p">;</span>
<span class="w">        </span><span class="n">GraphicsAPI</span><span class="o">::</span><span class="n">Viewport</span><span class="w"> </span><span class="n">viewport</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">height</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">};</span>
<span class="w">        </span><span class="n">GraphicsAPI</span><span class="o">::</span><span class="n">Rect2D</span><span class="w"> </span><span class="n">scissor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{{(</span><span class="kt">int32_t</span><span class="p">)</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int32_t</span><span class="p">)</span><span class="mi">0</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">}};</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">nearZ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.05f</span><span class="p">;</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">farZ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">100.0f</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// Fill out the XrCompositionLayerProjectionView structure specifying the pose and fov from the view.</span>
<span class="w">        </span><span class="c1">// This also associates the swapchain image with this layer projection view.</span>
<span class="w">        </span><span class="n">renderLayerInfo</span><span class="p">.</span><span class="n">layerProjectionViews</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">XR_TYPE_COMPOSITION_LAYER_PROJECTION_VIEW</span><span class="p">};</span>
<span class="w">        </span><span class="n">renderLayerInfo</span><span class="p">.</span><span class="n">layerProjectionViews</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pose</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">views</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pose</span><span class="p">;</span>
<span class="w">        </span><span class="n">renderLayerInfo</span><span class="p">.</span><span class="n">layerProjectionViews</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">fov</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">views</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">fov</span><span class="p">;</span>
<span class="w">        </span><span class="n">renderLayerInfo</span><span class="p">.</span><span class="n">layerProjectionViews</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">subImage</span><span class="p">.</span><span class="n">swapchain</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">colorSwapchainInfo</span><span class="p">.</span><span class="n">swapchain</span><span class="p">;</span>
<span class="w">        </span><span class="n">renderLayerInfo</span><span class="p">.</span><span class="n">layerProjectionViews</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">subImage</span><span class="p">.</span><span class="n">imageRect</span><span class="p">.</span><span class="n">offset</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="n">renderLayerInfo</span><span class="p">.</span><span class="n">layerProjectionViews</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">subImage</span><span class="p">.</span><span class="n">imageRect</span><span class="p">.</span><span class="n">offset</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="n">renderLayerInfo</span><span class="p">.</span><span class="n">layerProjectionViews</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">subImage</span><span class="p">.</span><span class="n">imageRect</span><span class="p">.</span><span class="n">extent</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">width</span><span class="p">);</span>
<span class="w">        </span><span class="n">renderLayerInfo</span><span class="p">.</span><span class="n">layerProjectionViews</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">subImage</span><span class="p">.</span><span class="n">imageRect</span><span class="p">.</span><span class="n">extent</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">height</span><span class="p">);</span>
<span class="w">        </span><span class="n">renderLayerInfo</span><span class="p">.</span><span class="n">layerProjectionViews</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">subImage</span><span class="p">.</span><span class="n">imageArrayIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="c1">// Useful for multiview rendering.</span>

<span class="w">        </span><span class="c1">// Rendering code to clear the color and depth image views.</span>
<span class="w">        </span><span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">BeginRendering</span><span class="p">();</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_environmentBlendMode</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">XR_ENVIRONMENT_BLEND_MODE_OPAQUE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// VR mode use a background color.</span>
<span class="w">            </span><span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">ClearColor</span><span class="p">(</span><span class="n">colorSwapchainInfo</span><span class="p">.</span><span class="n">imageViews</span><span class="p">[</span><span class="n">colorImageIndex</span><span class="p">],</span><span class="w"> </span><span class="mf">0.17f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.17f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.17f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.00f</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// In AR mode make the background color black.</span>
<span class="w">            </span><span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">ClearColor</span><span class="p">(</span><span class="n">colorSwapchainInfo</span><span class="p">.</span><span class="n">imageViews</span><span class="p">[</span><span class="n">colorImageIndex</span><span class="p">],</span><span class="w"> </span><span class="mf">0.00f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.00f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.00f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.00f</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">ClearDepth</span><span class="p">(</span><span class="n">depthSwapchainInfo</span><span class="p">.</span><span class="n">imageViews</span><span class="p">[</span><span class="n">depthImageIndex</span><span class="p">],</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">);</span>
</pre></div>
</div>
<p>And add the following:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">        </span><span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">EndRendering</span><span class="p">();</span>

<span class="w">        </span><span class="c1">// Give the swapchain image back to OpenXR, allowing the compositor to use the image.</span>
<span class="w">        </span><span class="n">XrSwapchainImageReleaseInfo</span><span class="w"> </span><span class="n">releaseInfo</span><span class="p">{</span><span class="n">XR_TYPE_SWAPCHAIN_IMAGE_RELEASE_INFO</span><span class="p">};</span>
<span class="w">        </span><span class="n">OPENXR_CHECK</span><span class="p">(</span><span class="n">xrReleaseSwapchainImage</span><span class="p">(</span><span class="n">colorSwapchainInfo</span><span class="p">.</span><span class="n">swapchain</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">releaseInfo</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Failed to release Image back to the Color Swapchain&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">OPENXR_CHECK</span><span class="p">(</span><span class="n">xrReleaseSwapchainImage</span><span class="p">(</span><span class="n">depthSwapchainInfo</span><span class="p">.</span><span class="n">swapchain</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">releaseInfo</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Failed to release Image back to the Depth Swapchain&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Fill out the XrCompositionLayerProjection structure for usage with xrEndFrame().</span>
<span class="w">    </span><span class="n">renderLayerInfo</span><span class="p">.</span><span class="n">layerProjection</span><span class="p">.</span><span class="n">layerFlags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">XR_COMPOSITION_LAYER_BLEND_TEXTURE_SOURCE_ALPHA_BIT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">XR_COMPOSITION_LAYER_CORRECT_CHROMATIC_ABERRATION_BIT</span><span class="p">;</span>
<span class="w">    </span><span class="n">renderLayerInfo</span><span class="p">.</span><span class="n">layerProjection</span><span class="p">.</span><span class="n">space</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_localSpace</span><span class="p">;</span>
<span class="w">    </span><span class="n">renderLayerInfo</span><span class="p">.</span><span class="n">layerProjection</span><span class="p">.</span><span class="n">viewCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">renderLayerInfo</span><span class="p">.</span><span class="n">layerProjectionViews</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
<span class="w">    </span><span class="n">renderLayerInfo</span><span class="p">.</span><span class="n">layerProjection</span><span class="p">.</span><span class="n">views</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">renderLayerInfo</span><span class="p">.</span><span class="n">layerProjectionViews</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
</pre></div>
</div>
<p>Our first call is to <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/xrLocateViews.html">xrLocateViews</a>, which takes a <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrViewLocateInfo.html">XrViewLocateInfo</a> structure and return an <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrViewState.html">XrViewState</a> structure and an array of <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrView.html">XrView</a> s. This function tells us where the views are in relation to the reference space, as an <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrPosef.html">XrPosef</a>, as well as the field of view, as an <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrFovf.html">XrFovf</a>, for each view; this information is stored in the <code class="docutils literal notranslate"><span class="pre">std::vector&lt;XrView&gt;</span></code>. The returned <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrViewState.html">XrViewState</a> contains a member of type <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrViewStateFlags.html">XrViewStateFlags</a>, which describes whether the position and/or orientation is valid and/or tracked. An <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrPosef.html">XrPosef</a> contain both a vector 3 position and a quaternion orientation, which together describe a transform in 3D space. An <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrFovf.html">XrFovf</a> contain four angles (left, right, up and down), which describe the angular extent of the view’s frustum about the view’s central axis.</p>
<p>The <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrViewLocateInfo.html">XrViewLocateInfo</a> structure takes a reference space and a display time from our <code class="docutils literal notranslate"><span class="pre">RenderLayerInfo</span></code>, from which the view poses are calculated, and also takes our <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrViewConfigurationType.html">XrViewConfigurationType</a> to locate the correct number of views for the system. If we can’t locate the views, we return <code class="docutils literal notranslate"><span class="pre">false</span></code> from this method.</p>
<p>We resize our <code class="docutils literal notranslate"><span class="pre">std::vector&lt;XrCompositionLayerProjectionView&gt;</span></code> member in <code class="docutils literal notranslate"><span class="pre">RenderLayerInfo</span></code>, and for each view, we render our graphics based on the acquired <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrView.html">XrView</a>.</p>
<p>The following sections are repeated for each view whilst we are in the loop, which iterates over the views.</p>
<p>We now acquire both a color and depth image from the swapchains to render to by calling <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/xrAcquireSwapchainImage.html">xrAcquireSwapchainImage</a>. This returns via a parameter an index, which we can use to index into an array of swapchain images, or in the case of this tutorial the array of structures containing our swapchain images. Next, we call <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/xrWaitSwapchainImage.html">xrWaitSwapchainImage</a> for both swapchains, we do this to avoid writing to images that the OpenXR compositor is still reading from. These calls will block the CPU thread until the swapchain images are available to use. Skipping slightly forward to the end of the rendering for this view, we call <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/xrReleaseSwapchainImage.html">xrReleaseSwapchainImage</a> for the color and depth swapchains. These calls hand the swapchain images back to OpenXR for the compositor to use in creating the image for the view. Like with <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/xrBeginFrame.html">xrBeginFrame</a> and <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/xrEndFrame.html">xrEndFrame</a>, the <code class="docutils literal notranslate"><span class="pre">xr...SwapchainImage()</span></code> functions need to be called in sequence for correct API usage.</p>
<p>After we have waited for the swapchain images, but before releasing it, we fill out the <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrCompositionLayerProjectionView.html">XrCompositionLayerProjectionView</a> associated with the view and render our graphics. First, we quickly get the <code class="docutils literal notranslate"><span class="pre">width</span></code> and <code class="docutils literal notranslate"><span class="pre">height</span></code> of the view from the <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrViewConfigurationView.html">XrViewConfigurationView</a>. We used the same <code class="docutils literal notranslate"><span class="pre">recommendedImageRectWidth</span></code> and <code class="docutils literal notranslate"><span class="pre">recommendedImageRectHeight</span></code> values when creating the swapchains. We also create the viewport, scissor, nearZ and farZ values for rendering.</p>
<p>We can now fill out the <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrCompositionLayerProjectionView.html">XrCompositionLayerProjectionView</a> using the <code class="docutils literal notranslate"><span class="pre">pose</span></code> and <code class="docutils literal notranslate"><span class="pre">fov</span></code> from the associated <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrView.html">XrView</a>. For the <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrSwapchainSubImage.html">XrSwapchainSubImage</a> member, we assign the color <code class="docutils literal notranslate"><span class="pre">swapchain</span></code> used, the <code class="docutils literal notranslate"><span class="pre">offset</span></code> and <code class="docutils literal notranslate"><span class="pre">extent</span></code> of the render area and <code class="docutils literal notranslate"><span class="pre">imageArrayIndex</span></code>. If you are using multiview rendering and your single swapchain is comprised of 2D Array images, where each subresource layer in the image relates to a view, you can use <code class="docutils literal notranslate"><span class="pre">imageArrayIndex</span></code> to specify the subresource layer of the image used in the rendering of this view. (See <a class="reference internal" href="6-next-steps.html#multiview-rendering"><span class="std std-ref">Chapter 6.1</span></a>).</p>
<p>After filling out the <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrCompositionLayerProjectionView.html">XrCompositionLayerProjectionView</a> structure, we can use this tutorial’s <code class="docutils literal notranslate"><span class="pre">GraphicsAPI</span></code> to clear the images as a very simple test. We first call <code class="docutils literal notranslate"><span class="pre">GraphicsAPI::BeginRendering()</span></code> to setup any API-specific objects needed for rendering. Next, we call <code class="docutils literal notranslate"><span class="pre">GraphicsAPI::ClearColor()</span></code> taking the created color image view from the color swapchain image; note here that we use different clear colors depending on whether our environment blend mode is opaque or otherwise. We also clear our depth image view, which was created from the depth swapchain image, with <code class="docutils literal notranslate"><span class="pre">GraphicsAPI::ClearDepth()</span></code>. Finally, we call <code class="docutils literal notranslate"><span class="pre">GraphicsAPI::EndRendering()</span></code> to finish the rendering. This function will submit the work to the GPU and wait for it to be completed.</p>
<p>Now, we have rendered both views and exited the loop.</p>
<p>We fill out the <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrCompositionLayerProjection.html">XrCompositionLayerProjection</a> structure and assign our compositing flags of <code class="docutils literal notranslate"><span class="pre">XR_COMPOSITION_LAYER_BLEND_TEXTURE_SOURCE_ALPHA_BIT</span> <span class="pre">|</span> <span class="pre">XR_COMPOSITION_LAYER_CORRECT_CHROMATIC_ABERRATION_BIT</span></code> and assign our reference space. We assign to the member <code class="docutils literal notranslate"><span class="pre">viewCount</span></code> the size of the <code class="docutils literal notranslate"><span class="pre">std::vector&lt;XrCompositionLayerProjectionView&gt;</span></code> and to the member <code class="docutils literal notranslate"><span class="pre">views</span></code> a pointer to the first element in the <code class="docutils literal notranslate"><span class="pre">std::vector&lt;XrCompositionLayerProjectionView&gt;</span></code>. Finally, we return <code class="docutils literal notranslate"><span class="pre">true</span></code> from the function to state that we have successfully completed our rendering.</p>
<p>We should now have clear colors rendered to each view in your XR system. From here, you can easily expand the graphical complexity of the scene.</p>
</section>
</section>
<section id="rendering-cuboids">
<h2>3.3 Rendering Cuboids<a class="headerlink" href="#rendering-cuboids" title="Link to this heading">¶</a></h2>
<p>Now that we have a clear color and depth working, we can now start to render geometry in our scene. We will use <code class="docutils literal notranslate"><span class="pre">GraphicsAPI</span></code> to create vertex, index and uniform/constant buffers along with shaders and a pipeline to render some cuboids representing the floor and a table surface.</p>
<p>Update the methods and members in the class. Copy the highlighted code:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos">  1</span><span class="k">class</span><span class="w"> </span><span class="nc">OpenXRTutorial</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">  2</span><span class="k">private</span><span class="o">:</span>
<span class="linenos">  3</span><span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">RenderLayerInfo</span><span class="p">;</span>
<span class="linenos">  4</span>
<span class="linenos">  5</span><span class="k">public</span><span class="o">:</span>
<span class="linenos">  6</span><span class="w">        </span><span class="c1">// [...] Constructor and Destructor created in previous chapters.</span>
<span class="linenos">  7</span>
<span class="linenos">  8</span><span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="n">Run</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">  9</span><span class="w">                </span><span class="n">CreateInstance</span><span class="p">();</span>
<span class="linenos"> 10</span><span class="w">                </span><span class="n">CreateDebugMessenger</span><span class="p">();</span>
<span class="linenos"> 11</span>
<span class="linenos"> 12</span><span class="w">                </span><span class="n">GetInstanceProperties</span><span class="p">();</span>
<span class="linenos"> 13</span><span class="w">                </span><span class="n">GetSystemID</span><span class="p">();</span>
<span class="linenos"> 14</span>
<span class="linenos"> 15</span><span class="w">                </span><span class="n">GetViewConfigurationViews</span><span class="p">();</span>
<span class="linenos"> 16</span><span class="w">                </span><span class="n">GetEnvironmentBlendModes</span><span class="p">();</span>
<span class="linenos"> 17</span>
<span class="linenos"> 18</span><span class="w">                </span><span class="n">CreateSession</span><span class="p">();</span>
<span class="linenos"> 19</span><span class="w">                </span><span class="n">CreateReferenceSpace</span><span class="p">();</span>
<span class="linenos"> 20</span><span class="w">                </span><span class="n">CreateSwapchains</span><span class="p">();</span>
<span class="hll"><span class="linenos"> 21</span><span class="w">                </span><span class="n">CreateResources</span><span class="p">();</span>
</span><span class="linenos"> 22</span>
<span class="linenos"> 23</span><span class="w">                </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">m_applicationRunning</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 24</span><span class="w">                        </span><span class="n">PollSystemEvents</span><span class="p">();</span>
<span class="linenos"> 25</span><span class="w">                        </span><span class="n">PollEvents</span><span class="p">();</span>
<span class="linenos"> 26</span><span class="w">                        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_sessionRunning</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 27</span><span class="w">                                </span><span class="n">RenderFrame</span><span class="p">();</span>
<span class="linenos"> 28</span><span class="w">                        </span><span class="p">}</span>
<span class="linenos"> 29</span><span class="w">                </span><span class="p">}</span>
<span class="linenos"> 30</span>
<span class="hll"><span class="linenos"> 31</span><span class="w">                </span><span class="n">DestroyResources</span><span class="p">();</span>
</span><span class="linenos"> 32</span><span class="w">                </span><span class="n">DestroySwapchains</span><span class="p">();</span>
<span class="linenos"> 33</span><span class="w">                </span><span class="n">DestroyReferenceSpace</span><span class="p">();</span>
<span class="linenos"> 34</span><span class="w">                </span><span class="n">DestroySession</span><span class="p">();</span>
<span class="linenos"> 35</span>
<span class="linenos"> 36</span><span class="w">                </span><span class="n">DestroyDebugMessenger</span><span class="p">();</span>
<span class="linenos"> 37</span><span class="w">                </span><span class="n">DestroyInstance</span><span class="p">();</span>
<span class="linenos"> 38</span><span class="w">        </span><span class="p">}</span>
<span class="linenos"> 39</span>
<span class="linenos"> 40</span><span class="k">private</span><span class="o">:</span>
<span class="linenos"> 41</span><span class="w">        </span><span class="c1">// [...] Methods created in previous chapters.</span>
<span class="linenos"> 42</span>
<span class="linenos"> 43</span><span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="n">GetViewConfigurationViews</span><span class="p">()</span>
<span class="linenos"> 44</span><span class="w">        </span><span class="p">{</span>
<span class="linenos"> 45</span><span class="w">                </span><span class="c1">// [...]</span>
<span class="linenos"> 46</span><span class="w">        </span><span class="p">}</span>
<span class="linenos"> 47</span><span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="n">CreateSwapchains</span><span class="p">()</span>
<span class="linenos"> 48</span><span class="w">        </span><span class="p">{</span>
<span class="linenos"> 49</span><span class="w">                </span><span class="c1">// [...]</span>
<span class="linenos"> 50</span><span class="w">        </span><span class="p">}</span>
<span class="linenos"> 51</span><span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="n">DestroySwapchains</span><span class="p">()</span>
<span class="linenos"> 52</span><span class="w">        </span><span class="p">{</span>
<span class="linenos"> 53</span><span class="w">                </span><span class="c1">// [...]</span>
<span class="linenos"> 54</span><span class="w">        </span><span class="p">}</span>
<span class="linenos"> 55</span><span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="n">GetEnvironmentBlendModes</span><span class="p">()</span>
<span class="linenos"> 56</span><span class="w">        </span><span class="p">{</span>
<span class="linenos"> 57</span><span class="w">                </span><span class="c1">// [...]</span>
<span class="linenos"> 58</span><span class="w">        </span><span class="p">}</span>
<span class="linenos"> 59</span><span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="n">CreateReferenceSpace</span><span class="p">()</span>
<span class="linenos"> 60</span><span class="w">        </span><span class="p">{</span>
<span class="linenos"> 61</span><span class="w">                </span><span class="c1">// [...]</span>
<span class="linenos"> 62</span><span class="w">        </span><span class="p">}</span>
<span class="linenos"> 63</span><span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="n">DestroyReferenceSpace</span><span class="p">()</span>
<span class="linenos"> 64</span><span class="w">        </span><span class="p">{</span>
<span class="linenos"> 65</span><span class="w">                </span><span class="c1">// [...]</span>
<span class="linenos"> 66</span><span class="w">        </span><span class="p">}</span>
<span class="linenos"> 67</span><span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="n">RenderFrame</span><span class="p">()</span>
<span class="linenos"> 68</span><span class="w">        </span><span class="p">{</span>
<span class="linenos"> 69</span><span class="w">                </span><span class="c1">// [...]</span>
<span class="linenos"> 70</span><span class="w">        </span><span class="p">}</span>
<span class="linenos"> 71</span><span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">RenderLayer</span><span class="p">(</span><span class="n">RenderLayerInfo</span><span class="o">&amp;</span><span class="w"> </span><span class="n">renderLayerInfo</span><span class="p">)</span>
<span class="linenos"> 72</span><span class="w">        </span><span class="p">{</span>
<span class="linenos"> 73</span><span class="w">                </span><span class="c1">// [...]</span>
<span class="linenos"> 74</span><span class="w">        </span><span class="p">}</span>
<span class="hll"><span class="linenos"> 75</span><span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="n">RenderCuboid</span><span class="p">(</span><span class="n">XrPosef</span><span class="w"> </span><span class="n">pose</span><span class="p">,</span><span class="w"> </span><span class="n">XrVector3f</span><span class="w"> </span><span class="n">scale</span><span class="p">,</span><span class="w"> </span><span class="n">XrVector3f</span><span class="w"> </span><span class="n">color</span><span class="p">)</span>
</span><span class="hll"><span class="linenos"> 76</span><span class="w">        </span><span class="p">{</span>
</span><span class="hll"><span class="linenos"> 77</span><span class="w">        </span><span class="p">}</span>
</span><span class="hll"><span class="linenos"> 78</span><span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="n">CreateResources</span><span class="p">()</span>
</span><span class="hll"><span class="linenos"> 79</span><span class="w">        </span><span class="p">{</span>
</span><span class="hll"><span class="linenos"> 80</span><span class="w">        </span><span class="p">}</span>
</span><span class="hll"><span class="linenos"> 81</span><span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="n">DestroyResources</span><span class="p">()</span>
</span><span class="hll"><span class="linenos"> 82</span><span class="w">        </span><span class="p">{</span>
</span><span class="hll"><span class="linenos"> 83</span><span class="w">        </span><span class="p">}</span>
</span><span class="linenos"> 84</span>
<span class="linenos"> 85</span><span class="k">private</span><span class="o">:</span>
<span class="linenos"> 86</span><span class="w">        </span><span class="c1">// [...] Members created in previous chapters.</span>
<span class="linenos"> 87</span>
<span class="linenos"> 88</span><span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">XrViewConfigurationType</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m_applicationViewConfigurations</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">XR_VIEW_CONFIGURATION_TYPE_PRIMARY_STEREO</span><span class="p">,</span><span class="w"> </span><span class="n">XR_VIEW_CONFIGURATION_TYPE_PRIMARY_MONO</span><span class="p">};</span>
<span class="linenos"> 89</span><span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">XrViewConfigurationType</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m_viewConfigurations</span><span class="p">;</span>
<span class="linenos"> 90</span><span class="w">        </span><span class="n">XrViewConfigurationType</span><span class="w"> </span><span class="n">m_viewConfiguration</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">XR_VIEW_CONFIGURATION_TYPE_MAX_ENUM</span><span class="p">;</span>
<span class="linenos"> 91</span><span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">XrViewConfigurationView</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m_viewConfigurationViews</span><span class="p">;</span>
<span class="linenos"> 92</span>
<span class="linenos"> 93</span><span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">SwapchainInfo</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 94</span><span class="w">                </span><span class="n">XrSwapchain</span><span class="w"> </span><span class="n">swapchain</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">XR_NULL_HANDLE</span><span class="p">;</span>
<span class="linenos"> 95</span><span class="w">                </span><span class="kt">int64_t</span><span class="w"> </span><span class="n">swapchainFormat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="linenos"> 96</span><span class="w">                </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">void</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="n">imageViews</span><span class="p">;</span>
<span class="linenos"> 97</span><span class="w">        </span><span class="p">};</span>
<span class="linenos"> 98</span><span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SwapchainInfo</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m_colorSwapchainInfos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
<span class="linenos"> 99</span><span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SwapchainInfo</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m_depthSwapchainInfos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
<span class="linenos">100</span>
<span class="linenos">101</span><span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">XrEnvironmentBlendMode</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m_applicationEnvironmentBlendModes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">XR_ENVIRONMENT_BLEND_MODE_OPAQUE</span><span class="p">,</span><span class="w"> </span><span class="n">XR_ENVIRONMENT_BLEND_MODE_ADDITIVE</span><span class="p">};</span>
<span class="linenos">102</span><span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">XrEnvironmentBlendMode</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m_environmentBlendModes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
<span class="linenos">103</span><span class="w">        </span><span class="n">XrEnvironmentBlendMode</span><span class="w"> </span><span class="n">m_environmentBlendMode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">XR_ENVIRONMENT_BLEND_MODE_MAX_ENUM</span><span class="p">;</span>
<span class="linenos">104</span>
<span class="linenos">105</span><span class="w">        </span><span class="n">XrSpace</span><span class="w"> </span><span class="n">m_localSpace</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">XR_NULL_HANDLE</span><span class="p">;</span>
<span class="linenos">106</span><span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">RenderLayerInfo</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">107</span><span class="w">                </span><span class="n">XrTime</span><span class="w"> </span><span class="n">predictedDisplayTime</span><span class="p">;</span>
<span class="linenos">108</span><span class="w">                </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">XrCompositionLayerBaseHeader</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="n">layers</span><span class="p">;</span>
<span class="linenos">109</span><span class="w">                </span><span class="n">XrCompositionLayerProjection</span><span class="w"> </span><span class="n">layerProjection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">XR_TYPE_COMPOSITION_LAYER_PROJECTION</span><span class="p">};</span>
<span class="linenos">110</span><span class="w">                </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">XrCompositionLayerProjectionView</span><span class="o">&gt;</span><span class="w"> </span><span class="n">layerProjectionViews</span><span class="p">;</span>
<span class="linenos">111</span><span class="w">        </span><span class="p">};</span>
<span class="linenos">112</span>
<span class="hll"><span class="linenos">113</span><span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">m_viewHeightM</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.5f</span><span class="p">;</span>
</span><span class="hll"><span class="linenos">114</span>
</span><span class="hll"><span class="linenos">115</span><span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">m_vertexBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
</span><span class="hll"><span class="linenos">116</span><span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">m_indexBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
</span><span class="hll"><span class="linenos">117</span><span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">m_uniformBuffer_Camera</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
</span><span class="hll"><span class="linenos">118</span><span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">m_uniformBuffer_Normals</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
</span><span class="hll"><span class="linenos">119</span><span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">m_vertexShader</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">m_fragmentShader</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
</span><span class="hll"><span class="linenos">120</span><span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">m_pipeline</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
</span><span class="linenos">121</span><span class="p">};</span>
</pre></div>
</div>
<p>To draw our geometry, we will need a simple mathematics library for vectors, matrices and the like. Download this header file and place it in the <code class="docutils literal notranslate"><span class="pre">Common</span></code> folder under the <em>workspace</em> directory:</p>
<p><a class="reference download internal" download="" href="_downloads/f4aef9ec726fccc71e105bc0830d4ff3/xr_linear_algebra.h"><code class="xref download docutils literal notranslate"><span class="pre">Common/xr_linear_algebra.h</span></code></a></p>
<p>In <code class="docutils literal notranslate"><span class="pre">main.cpp</span></code>, add the following code under the current header include statements:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// include xr linear algebra for XrVector and XrMatrix classes.</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;xr_linear_algebra.h&gt;</span>
<span class="c1">// Declare some useful operators for vectors:</span>
<span class="n">XrVector3f</span><span class="w"> </span><span class="k">operator</span><span class="o">-</span><span class="p">(</span><span class="n">XrVector3f</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">XrVector3f</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="n">a</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">z</span><span class="p">};</span>
<span class="p">}</span>
<span class="n">XrVector3f</span><span class="w"> </span><span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="n">XrVector3f</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="n">a</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now, we will need to set up all of our rendering resources for our scene. This consists of a vertex/index buffer-pair that holds the geometry data for a cube and a uniform/constant buffer large enough to hold multiple instances of our <code class="docutils literal notranslate"><span class="pre">CameraConstants</span></code> struct. We use <code class="docutils literal notranslate"><span class="pre">GraphicsAPI::CreateBuffer()</span></code> to create and upload our data to the GPU.</p>
<p>Above <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">CreateResources()</span></code> add the following code defining <code class="docutils literal notranslate"><span class="pre">CameraConstants</span></code> and an array of <a class="reference external" href="https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrVector4f.html">XrVector4f</a> normals:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">CameraConstants</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">XrMatrix4x4f</span><span class="w"> </span><span class="n">viewProj</span><span class="p">;</span>
<span class="w">    </span><span class="n">XrMatrix4x4f</span><span class="w"> </span><span class="n">modelViewProj</span><span class="p">;</span>
<span class="w">    </span><span class="n">XrMatrix4x4f</span><span class="w"> </span><span class="n">model</span><span class="p">;</span>
<span class="w">    </span><span class="n">XrVector4f</span><span class="w"> </span><span class="n">color</span><span class="p">;</span>
<span class="w">    </span><span class="n">XrVector4f</span><span class="w"> </span><span class="n">pad1</span><span class="p">;</span>
<span class="w">    </span><span class="n">XrVector4f</span><span class="w"> </span><span class="n">pad2</span><span class="p">;</span>
<span class="w">    </span><span class="n">XrVector4f</span><span class="w"> </span><span class="n">pad3</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">CameraConstants</span><span class="w"> </span><span class="n">cameraConstants</span><span class="p">;</span>
<span class="n">XrVector4f</span><span class="w"> </span><span class="n">normals</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">{</span><span class="mf">1.00f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.00f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.00f</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="mf">-1.00f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.00f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.00f</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="mf">0.00f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.00f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.00f</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="mf">0.00f</span><span class="p">,</span><span class="w"> </span><span class="mf">-1.00f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.00f</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="mf">0.00f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.00f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.00f</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="mf">0.00f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-1.00f</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">}};</span>
</pre></div>
</div>
<p>Copy the following code into <code class="docutils literal notranslate"><span class="pre">CreateResources()</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">        </span><span class="c1">// Vertices for a 1x1x1 meter cube. (Left/Right, Top/Bottom, Front/Back)</span>
<span class="w">        </span><span class="k">constexpr</span><span class="w"> </span><span class="n">XrVector4f</span><span class="w"> </span><span class="n">vertexPositions</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="p">{</span><span class="o">+</span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="o">+</span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="o">+</span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">},</span>
<span class="w">            </span><span class="p">{</span><span class="o">+</span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="o">+</span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">-0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">},</span>
<span class="w">            </span><span class="p">{</span><span class="o">+</span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">-0.5f</span><span class="p">,</span><span class="w"> </span><span class="o">+</span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">},</span>
<span class="w">            </span><span class="p">{</span><span class="o">+</span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">-0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">-0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">},</span>
<span class="w">            </span><span class="p">{</span><span class="mf">-0.5f</span><span class="p">,</span><span class="w"> </span><span class="o">+</span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="o">+</span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">},</span>
<span class="w">            </span><span class="p">{</span><span class="mf">-0.5f</span><span class="p">,</span><span class="w"> </span><span class="o">+</span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">-0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">},</span>
<span class="w">            </span><span class="p">{</span><span class="mf">-0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">-0.5f</span><span class="p">,</span><span class="w"> </span><span class="o">+</span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">},</span>
<span class="w">            </span><span class="p">{</span><span class="mf">-0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">-0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">-0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">}};</span>

<span class="cp">#define CUBE_FACE(V1, V2, V3, V4, V5, V6) vertexPositions[V1], vertexPositions[V2], vertexPositions[V3], vertexPositions[V4], vertexPositions[V5], vertexPositions[V6],</span>

<span class="w">        </span><span class="n">XrVector4f</span><span class="w"> </span><span class="n">cubeVertices</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">CUBE_FACE</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">  </span><span class="c1">// -X</span>
<span class="w">            </span><span class="n">CUBE_FACE</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">)</span><span class="w">  </span><span class="c1">// +X</span>
<span class="w">            </span><span class="n">CUBE_FACE</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w">  </span><span class="c1">// -Y</span>
<span class="w">            </span><span class="n">CUBE_FACE</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">  </span><span class="c1">// +Y</span>
<span class="w">            </span><span class="n">CUBE_FACE</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">  </span><span class="c1">// -Z</span>
<span class="w">            </span><span class="n">CUBE_FACE</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w">  </span><span class="c1">// +Z</span>
<span class="w">        </span><span class="p">};</span>

<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">cubeIndices</span><span class="p">[</span><span class="mi">36</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w">        </span><span class="c1">// -X</span>
<span class="w">            </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">11</span><span class="p">,</span><span class="w">      </span><span class="c1">// +X</span>
<span class="w">            </span><span class="mi">12</span><span class="p">,</span><span class="w"> </span><span class="mi">13</span><span class="p">,</span><span class="w"> </span><span class="mi">14</span><span class="p">,</span><span class="w"> </span><span class="mi">15</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="mi">17</span><span class="p">,</span><span class="w">  </span><span class="c1">// -Y</span>
<span class="w">            </span><span class="mi">18</span><span class="p">,</span><span class="w"> </span><span class="mi">19</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="mi">21</span><span class="p">,</span><span class="w"> </span><span class="mi">22</span><span class="p">,</span><span class="w"> </span><span class="mi">23</span><span class="p">,</span><span class="w">  </span><span class="c1">// +Y</span>
<span class="w">            </span><span class="mi">24</span><span class="p">,</span><span class="w"> </span><span class="mi">25</span><span class="p">,</span><span class="w"> </span><span class="mi">26</span><span class="p">,</span><span class="w"> </span><span class="mi">27</span><span class="p">,</span><span class="w"> </span><span class="mi">28</span><span class="p">,</span><span class="w"> </span><span class="mi">29</span><span class="p">,</span><span class="w">  </span><span class="c1">// -Z</span>
<span class="w">            </span><span class="mi">30</span><span class="p">,</span><span class="w"> </span><span class="mi">31</span><span class="p">,</span><span class="w"> </span><span class="mi">32</span><span class="p">,</span><span class="w"> </span><span class="mi">33</span><span class="p">,</span><span class="w"> </span><span class="mi">34</span><span class="p">,</span><span class="w"> </span><span class="mi">35</span><span class="p">,</span><span class="w">  </span><span class="c1">// +Z</span>
<span class="w">        </span><span class="p">};</span>

<span class="w">        </span><span class="n">m_vertexBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">CreateBuffer</span><span class="p">({</span><span class="n">GraphicsAPI</span><span class="o">::</span><span class="n">BufferCreateInfo</span><span class="o">::</span><span class="n">Type</span><span class="o">::</span><span class="n">VERTEX</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">cubeVertices</span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cubeVertices</span><span class="p">});</span>

<span class="w">        </span><span class="n">m_indexBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">CreateBuffer</span><span class="p">({</span><span class="n">GraphicsAPI</span><span class="o">::</span><span class="n">BufferCreateInfo</span><span class="o">::</span><span class="n">Type</span><span class="o">::</span><span class="n">INDEX</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">),</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">cubeIndices</span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cubeIndices</span><span class="p">});</span>

<span class="w">        </span><span class="kt">size_t</span><span class="w"> </span><span class="n">numberOfCuboids</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">        </span><span class="n">m_uniformBuffer_Camera</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">CreateBuffer</span><span class="p">({</span><span class="n">GraphicsAPI</span><span class="o">::</span><span class="n">BufferCreateInfo</span><span class="o">::</span><span class="n">Type</span><span class="o">::</span><span class="n">UNIFORM</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">CameraConstants</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">numberOfCuboids</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">});</span>
<span class="w">        </span><span class="n">m_uniformBuffer_Normals</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">CreateBuffer</span><span class="p">({</span><span class="n">GraphicsAPI</span><span class="o">::</span><span class="n">BufferCreateInfo</span><span class="o">::</span><span class="n">Type</span><span class="o">::</span><span class="n">UNIFORM</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">normals</span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">normals</span><span class="p">});</span>
</pre></div>
</div>
<p>Now, we will add the code to load and create our shaders with <code class="docutils literal notranslate"><span class="pre">GraphicsAPI::CreateShader()</span></code>. Copy the following code into <code class="docutils literal notranslate"><span class="pre">CreateResources()</span></code>:</p>
<p>For Vulkan, we will use GLSL version 450. Add this code to define our vertex and pixel shaders:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_apiType</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">VULKAN</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vertexSource</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ReadBinaryFile</span><span class="p">(</span><span class="s">&quot;VertexShader.spv&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">m_vertexShader</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">CreateShader</span><span class="p">({</span><span class="n">GraphicsAPI</span><span class="o">::</span><span class="n">ShaderCreateInfo</span><span class="o">::</span><span class="n">Type</span><span class="o">::</span><span class="n">VERTEX</span><span class="p">,</span><span class="w"> </span><span class="n">vertexSource</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="n">vertexSource</span><span class="p">.</span><span class="n">size</span><span class="p">()});</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="w"> </span><span class="n">fragmentSource</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ReadBinaryFile</span><span class="p">(</span><span class="s">&quot;PixelShader.spv&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">m_fragmentShader</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">CreateShader</span><span class="p">({</span><span class="n">GraphicsAPI</span><span class="o">::</span><span class="n">ShaderCreateInfo</span><span class="o">::</span><span class="n">Type</span><span class="o">::</span><span class="n">FRAGMENT</span><span class="p">,</span><span class="w"> </span><span class="n">fragmentSource</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="n">fragmentSource</span><span class="p">.</span><span class="n">size</span><span class="p">()});</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now we’ll combine the shaders, the vertex input layout, and the rendering state for drawing a solid cube, into a pipeline object using <code class="docutils literal notranslate"><span class="pre">GraphicsAPI::CreatePipeline()</span></code>. Add the following code to <code class="docutils literal notranslate"><span class="pre">CreateResources()</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">GraphicsAPI</span><span class="o">::</span><span class="n">PipelineCreateInfo</span><span class="w"> </span><span class="n">pipelineCI</span><span class="p">;</span>
<span class="n">pipelineCI</span><span class="p">.</span><span class="n">shaders</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">m_vertexShader</span><span class="p">,</span><span class="w"> </span><span class="n">m_fragmentShader</span><span class="p">};</span>
<span class="n">pipelineCI</span><span class="p">.</span><span class="n">vertexInputState</span><span class="p">.</span><span class="n">attributes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">GraphicsAPI</span><span class="o">::</span><span class="n">VertexType</span><span class="o">::</span><span class="n">VEC4</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;TEXCOORD&quot;</span><span class="p">}};</span>
<span class="n">pipelineCI</span><span class="p">.</span><span class="n">vertexInputState</span><span class="p">.</span><span class="n">bindings</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)}};</span>
<span class="n">pipelineCI</span><span class="p">.</span><span class="n">inputAssemblyState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">GraphicsAPI</span><span class="o">::</span><span class="n">PrimitiveTopology</span><span class="o">::</span><span class="n">TRIANGLE_LIST</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">};</span>
<span class="n">pipelineCI</span><span class="p">.</span><span class="n">rasterisationState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="n">GraphicsAPI</span><span class="o">::</span><span class="n">PolygonMode</span><span class="o">::</span><span class="n">FILL</span><span class="p">,</span><span class="w"> </span><span class="n">GraphicsAPI</span><span class="o">::</span><span class="n">CullMode</span><span class="o">::</span><span class="n">BACK</span><span class="p">,</span><span class="w"> </span><span class="n">GraphicsAPI</span><span class="o">::</span><span class="n">FrontFace</span><span class="o">::</span><span class="n">COUNTER_CLOCKWISE</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">};</span>
<span class="n">pipelineCI</span><span class="p">.</span><span class="n">multisampleState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mh">0xFFFFFFFF</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">};</span>
<span class="n">pipelineCI</span><span class="p">.</span><span class="n">depthStencilState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="n">GraphicsAPI</span><span class="o">::</span><span class="n">CompareOp</span><span class="o">::</span><span class="n">LESS_OR_EQUAL</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="p">{},</span><span class="w"> </span><span class="p">{},</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">};</span>
<span class="n">pipelineCI</span><span class="p">.</span><span class="n">colorBlendState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="n">GraphicsAPI</span><span class="o">::</span><span class="n">LogicOp</span><span class="o">::</span><span class="n">NO_OP</span><span class="p">,</span><span class="w"> </span><span class="p">{{</span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="n">GraphicsAPI</span><span class="o">::</span><span class="n">BlendFactor</span><span class="o">::</span><span class="n">SRC_ALPHA</span><span class="p">,</span><span class="w"> </span><span class="n">GraphicsAPI</span><span class="o">::</span><span class="n">BlendFactor</span><span class="o">::</span><span class="n">ONE_MINUS_SRC_ALPHA</span><span class="p">,</span><span class="w"> </span><span class="n">GraphicsAPI</span><span class="o">::</span><span class="n">BlendOp</span><span class="o">::</span><span class="n">ADD</span><span class="p">,</span><span class="w"> </span><span class="n">GraphicsAPI</span><span class="o">::</span><span class="n">BlendFactor</span><span class="o">::</span><span class="n">ONE</span><span class="p">,</span><span class="w"> </span><span class="n">GraphicsAPI</span><span class="o">::</span><span class="n">BlendFactor</span><span class="o">::</span><span class="n">ZERO</span><span class="p">,</span><span class="w"> </span><span class="n">GraphicsAPI</span><span class="o">::</span><span class="n">BlendOp</span><span class="o">::</span><span class="n">ADD</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">GraphicsAPI</span><span class="o">::</span><span class="n">ColorComponentBit</span><span class="p">)</span><span class="mi">15</span><span class="p">}},</span><span class="w"> </span><span class="p">{</span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">}};</span>
<span class="n">pipelineCI</span><span class="p">.</span><span class="n">colorFormats</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">m_colorSwapchainInfos</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">swapchainFormat</span><span class="p">};</span>
<span class="n">pipelineCI</span><span class="p">.</span><span class="n">depthFormat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_depthSwapchainInfos</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">swapchainFormat</span><span class="p">;</span>
<span class="n">pipelineCI</span><span class="p">.</span><span class="n">layout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="n">GraphicsAPI</span><span class="o">::</span><span class="n">DescriptorInfo</span><span class="o">::</span><span class="n">Type</span><span class="o">::</span><span class="n">BUFFER</span><span class="p">,</span><span class="w"> </span><span class="n">GraphicsAPI</span><span class="o">::</span><span class="n">DescriptorInfo</span><span class="o">::</span><span class="n">Stage</span><span class="o">::</span><span class="n">VERTEX</span><span class="p">},</span>
<span class="w">                     </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="n">GraphicsAPI</span><span class="o">::</span><span class="n">DescriptorInfo</span><span class="o">::</span><span class="n">Type</span><span class="o">::</span><span class="n">BUFFER</span><span class="p">,</span><span class="w"> </span><span class="n">GraphicsAPI</span><span class="o">::</span><span class="n">DescriptorInfo</span><span class="o">::</span><span class="n">Stage</span><span class="o">::</span><span class="n">VERTEX</span><span class="p">},</span>
<span class="w">                     </span><span class="p">{</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="n">GraphicsAPI</span><span class="o">::</span><span class="n">DescriptorInfo</span><span class="o">::</span><span class="n">Type</span><span class="o">::</span><span class="n">BUFFER</span><span class="p">,</span><span class="w"> </span><span class="n">GraphicsAPI</span><span class="o">::</span><span class="n">DescriptorInfo</span><span class="o">::</span><span class="n">Stage</span><span class="o">::</span><span class="n">FRAGMENT</span><span class="p">}};</span>
<span class="n">m_pipeline</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">CreatePipeline</span><span class="p">(</span><span class="n">pipelineCI</span><span class="p">);</span>
</pre></div>
</div>
<p>To destroy the resources, add this code into <code class="docutils literal notranslate"><span class="pre">DestroyResources()</span></code>, which use the corresponding <code class="docutils literal notranslate"><span class="pre">GraphicsAPI::Destroy...()</span></code> methods:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">DestroyPipeline</span><span class="p">(</span><span class="n">m_pipeline</span><span class="p">);</span>
<span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">DestroyShader</span><span class="p">(</span><span class="n">m_fragmentShader</span><span class="p">);</span>
<span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">DestroyShader</span><span class="p">(</span><span class="n">m_vertexShader</span><span class="p">);</span>
<span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">DestroyBuffer</span><span class="p">(</span><span class="n">m_uniformBuffer_Camera</span><span class="p">);</span>
<span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">DestroyBuffer</span><span class="p">(</span><span class="n">m_uniformBuffer_Normals</span><span class="p">);</span>
<span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">DestroyBuffer</span><span class="p">(</span><span class="n">m_indexBuffer</span><span class="p">);</span>
<span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">DestroyBuffer</span><span class="p">(</span><span class="n">m_vertexBuffer</span><span class="p">);</span>
</pre></div>
</div>
<p>With our rendering resources now set up, we can add the code needed for rendering the cuboids. We will set up the <code class="docutils literal notranslate"><span class="pre">RenderCuboid()</span></code> method, which is a little helper method that renders a cuboid. It also tracks the number of rendered cuboids with <code class="docutils literal notranslate"><span class="pre">renderCuboidIndex</span></code>. This is used so that we can correctly index into the right section of the uniform/constant buffer for positioning the cuboid and camera.</p>
<p>Above <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">RenderCuboid()</span></code>, add the following code:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">size_t</span><span class="w"> </span><span class="n">renderCuboidIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>Inside <code class="docutils literal notranslate"><span class="pre">RenderCuboid()</span></code>, add the following:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">XrMatrix4x4f_CreateTranslationRotationScale</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cameraConstants</span><span class="p">.</span><span class="n">model</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pose</span><span class="p">.</span><span class="n">position</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pose</span><span class="p">.</span><span class="n">orientation</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">scale</span><span class="p">);</span>

<span class="n">XrMatrix4x4f_Multiply</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cameraConstants</span><span class="p">.</span><span class="n">modelViewProj</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cameraConstants</span><span class="p">.</span><span class="n">viewProj</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cameraConstants</span><span class="p">.</span><span class="n">model</span><span class="p">);</span>
<span class="n">cameraConstants</span><span class="p">.</span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">color</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">color</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">color</span><span class="p">.</span><span class="n">z</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">};</span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">offsetCameraUB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">CameraConstants</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">renderCuboidIndex</span><span class="p">;</span>

<span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">SetPipeline</span><span class="p">(</span><span class="n">m_pipeline</span><span class="p">);</span>

<span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">SetBufferData</span><span class="p">(</span><span class="n">m_uniformBuffer_Camera</span><span class="p">,</span><span class="w"> </span><span class="n">offsetCameraUB</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">CameraConstants</span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cameraConstants</span><span class="p">);</span>
<span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">SetDescriptor</span><span class="p">({</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">m_uniformBuffer_Camera</span><span class="p">,</span><span class="w"> </span><span class="n">GraphicsAPI</span><span class="o">::</span><span class="n">DescriptorInfo</span><span class="o">::</span><span class="n">Type</span><span class="o">::</span><span class="n">BUFFER</span><span class="p">,</span><span class="w"> </span><span class="n">GraphicsAPI</span><span class="o">::</span><span class="n">DescriptorInfo</span><span class="o">::</span><span class="n">Stage</span><span class="o">::</span><span class="n">VERTEX</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="n">offsetCameraUB</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">CameraConstants</span><span class="p">)});</span>
<span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">SetDescriptor</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">m_uniformBuffer_Normals</span><span class="p">,</span><span class="w"> </span><span class="n">GraphicsAPI</span><span class="o">::</span><span class="n">DescriptorInfo</span><span class="o">::</span><span class="n">Type</span><span class="o">::</span><span class="n">BUFFER</span><span class="p">,</span><span class="w"> </span><span class="n">GraphicsAPI</span><span class="o">::</span><span class="n">DescriptorInfo</span><span class="o">::</span><span class="n">Stage</span><span class="o">::</span><span class="n">VERTEX</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">normals</span><span class="p">)});</span>

<span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">UpdateDescriptors</span><span class="p">();</span>

<span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">SetVertexBuffers</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_vertexBuffer</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">SetIndexBuffer</span><span class="p">(</span><span class="n">m_indexBuffer</span><span class="p">);</span>
<span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">DrawIndexed</span><span class="p">(</span><span class="mi">36</span><span class="p">);</span>

<span class="n">renderCuboidIndex</span><span class="o">++</span><span class="p">;</span>
</pre></div>
</div>
<p>From the passed-in pose and scale, we create the <code class="docutils literal notranslate"><span class="pre">model</span></code> matrix and multiply that with <code class="docutils literal notranslate"><span class="pre">CameraConstants::viewProj</span></code> to obtain <code class="docutils literal notranslate"><span class="pre">CameraConstants::modelViewProj</span></code>, the matrix that transforms the vertices in our unit cube from model space into projection space. We apply our <code class="docutils literal notranslate"><span class="pre">pipeline</span></code>, which contains the shaders and render states. We update the two uniform buffers, one containing cameraConstants for the vertex shader and the other containing the normals for the cuboid. We assign our vertex and index buffers and draw 36 indices.</p>
<p>Now moving to the <code class="docutils literal notranslate"><span class="pre">RenderLayer()</span></code> method. Under the call to <code class="docutils literal notranslate"><span class="pre">ClearDepth()</span></code>, and before the call to <code class="docutils literal notranslate"><span class="pre">EndRendering()</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">SetRenderAttachments</span><span class="p">(</span><span class="o">&amp;</span><span class="n">colorSwapchainInfo</span><span class="p">.</span><span class="n">imageViews</span><span class="p">[</span><span class="n">colorImageIndex</span><span class="p">],</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">depthSwapchainInfo</span><span class="p">.</span><span class="n">imageViews</span><span class="p">[</span><span class="n">depthImageIndex</span><span class="p">],</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">,</span><span class="w"> </span><span class="n">m_pipeline</span><span class="p">);</span>
<span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">SetViewports</span><span class="p">(</span><span class="o">&amp;</span><span class="n">viewport</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="n">m_graphicsAPI</span><span class="o">-&gt;</span><span class="n">SetScissors</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scissor</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>

<span class="c1">// Compute the view-projection transform.</span>
<span class="c1">// All matrices (including OpenXR&#39;s) are column-major, right-handed.</span>
<span class="n">XrMatrix4x4f</span><span class="w"> </span><span class="n">proj</span><span class="p">;</span>
<span class="n">XrMatrix4x4f_CreateProjectionFov</span><span class="p">(</span><span class="o">&amp;</span><span class="n">proj</span><span class="p">,</span><span class="w"> </span><span class="n">m_apiType</span><span class="p">,</span><span class="w"> </span><span class="n">views</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">fov</span><span class="p">,</span><span class="w"> </span><span class="n">nearZ</span><span class="p">,</span><span class="w"> </span><span class="n">farZ</span><span class="p">);</span>
<span class="n">XrMatrix4x4f</span><span class="w"> </span><span class="n">toView</span><span class="p">;</span>
<span class="n">XrVector3f</span><span class="w"> </span><span class="n">scale1m</span><span class="p">{</span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">};</span>
<span class="n">XrMatrix4x4f_CreateTranslationRotationScale</span><span class="p">(</span><span class="o">&amp;</span><span class="n">toView</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">views</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pose</span><span class="p">.</span><span class="n">position</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">views</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pose</span><span class="p">.</span><span class="n">orientation</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">scale1m</span><span class="p">);</span>
<span class="n">XrMatrix4x4f</span><span class="w"> </span><span class="n">view</span><span class="p">;</span>
<span class="n">XrMatrix4x4f_InvertRigidBody</span><span class="p">(</span><span class="o">&amp;</span><span class="n">view</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">toView</span><span class="p">);</span>
<span class="n">XrMatrix4x4f_Multiply</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cameraConstants</span><span class="p">.</span><span class="n">viewProj</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">proj</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">view</span><span class="p">);</span>
</pre></div>
</div>
<p>The section sets the color and depth image views as rendering attachments for the output merger/color blend stage to write to. We also set the viewport for the rasterizer to transform from normalized device coordinates to texel space and we set the scissor for the rasterizer to the cut in texel space. Our viewport and scissor cover the whole render area. Next, we compute projection and view matrices and we multiply them together to create a view-projection matrix for <code class="docutils literal notranslate"><span class="pre">CameraConstants::viewProj</span></code>. Now, add the following code:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">renderCuboidIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="c1">// Draw a floor. Scale it by 2 in the X and Z, and 0.1 in the Y,</span>
<span class="n">RenderCuboid</span><span class="p">({{</span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="n">m_viewHeightM</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">}},</span><span class="w"> </span><span class="p">{</span><span class="mf">2.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.1f</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0f</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mf">0.4f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.5f</span><span class="p">});</span>
<span class="c1">// Draw a &quot;table&quot;.</span>
<span class="n">RenderCuboid</span><span class="p">({{</span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="n">m_viewHeightM</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">0.9f</span><span class="p">,</span><span class="w"> </span><span class="mf">-0.7f</span><span class="p">}},</span><span class="w"> </span><span class="p">{</span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.2f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mf">0.6f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.6f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.4f</span><span class="p">});</span>
</pre></div>
</div>
<p>Finally, we set <code class="docutils literal notranslate"><span class="pre">renderCuboidIndex</span></code> to <code class="docutils literal notranslate"><span class="pre">0</span></code> and call <code class="docutils literal notranslate"><span class="pre">RenderCuboid()</span></code> twice drawing two cuboids. The first is offset by our (arbitrary) view height, to represent a “floor”. We scale it by 2 meters in the horizontal direction and 0.1 meter in the vertical, so it’s flat. With that, we should now have a clear color and two cuboids rendered to each view in your XR system.</p>
</section>
<section id="summary">
<h2>3.4 Summary<a class="headerlink" href="#summary" title="Link to this heading">¶</a></h2>
<p>Our XR application now renders graphics to the views and uses the XR compositor to present them correctly.
In the next chapter, we will discuss how to use OpenXR to interact with your XR application enabling new experiences in spatial computing.</p>
<p>Below is a download link to a zip archive for this chapter containing all the C++ and CMake code for all platform and graphics APIs.</p>
<p><a class="reference external" href="https://github.com/KhronosGroup/OpenXR-Tutorials/releases/download/v0.0.0/Chapter3.zip">Chapter3.zip</a></p>
<p>Version: v0.0.0</p>
</section>
</section>


					</div>
				</div>
				<footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="2-setup.html" class="btn btn-neutral float-left" title="2 OpenXR Setup" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="4-actions.html" class="btn btn-neutral float-right" title="4 Interactions" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr>

  <div role="contentinfo">
      <div class="legal-notice">
      <h3>Legal Notice</h3>
      <p>
      </p>
      <p>
        &#169; 2023, The Khronos Group. <a href="https://creativecommons.org/licenses/by/4.0/deed.en">Creative Commons International 4.0 BY Attribution</a>. Code is licensed as <a href="https://www.apache.org/licenses/LICENSE-2.0">Apache 2.0</a>.
      </p>
      <p>
        "OpenXR" and the OpenXR logo are trademarks owned by The Khronos Group Inc. and are registered as a trademark in China, the European Union, Japan and the United Kingdom. Vulkan and the Vulkan logo are registered trademarks of the Khronos Group Inc.
      </p>
      <p>
        OpenGL&reg; and the oval logo are trademarks or registered trademarks of Hewlett Packard Enterprise in the United States and/or other countries worldwide. OpenGL is a registered trademark and the OpenGL ES logo is a trademark of Hewlett Packard Enterprise used by permission by Khronos.
      </p>
      <p>
        Microsoft DirectX, Microsoft DirectX11, and Microsoft DirectX12 are trademarks owned by Microsoft.
      </p>
        
      <p>
        The OpenXR Tutorial is owned and operated by The Khronos Group Inc. Khronos <a href="https://www.khronos.org/legal/" rel="nofollow">Legal Notices</a>, <a href="https://www.khronos.org/legal/privacy" rel="nofollow">Privacy Policy</a>, and <a href="https://www.khronos.org/about/code-of-conduct" rel="nofollow">Code of Conduct</a> apply.
      </p>
      <p></p>
      </div>
  </div> 

</footer>
			</div>
			</div>
		</div>
	</div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>